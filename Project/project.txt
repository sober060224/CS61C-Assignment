Skip to main content
è·³è½¬åˆ°ä¸»è¦å†…å®¹
ğŸ‰ï¸ğŸ‰ï¸ğŸ‰ï¸è¯¾ç¨‹æ–‡æ¡£æ±‰åŒ–å·¥ä½œæ­£åœ¨è¿›è¡Œä¸­ ğŸ‰ï¸ğŸ‰ï¸ å­¦ä¹ äº¤æµç¾¤è¯·åˆ° ç¤¾åŒºé¡µé¢ æŸ¥çœ‹å…¥ç¾¤æ–¹å¼ ğŸ‰ï¸ğŸ‰ï¸ğŸ‰ï¸
TeachYourselfCS
TeachYourselfCS
è·¯çº¿å›¾
è¯¾ç¨‹èµ„æº
åšå®¢
ç¤¾åŒº
æèµ æˆ‘ä»¬

å‰è¨€
è·¯çº¿å›¾
è¯¾ç¨‹èµ„æº

cs50x

cs61a

cs61b

cs61c

syllabus-è¯¾ç¨‹å¤§çº²
labs
projects
  é¡¹ç›®
Project1
  é¡¹ç›® 1
Project2
  é¡¹ç›® 2
Project3
  é¡¹ç›® 3
Project4
  é¡¹ç›® 4
MIT 18.01

MIT 18.02

MIT 18.06

MIT 6.042J

cs162

cs144

CMU 15-445

py4e

è¯¾ç¨‹èµ„æºcs61cprojectsProject1
Project 1: Conway's Game of Life, in RGB! (Part A due 9/16, Part B due 9/19)
é¡¹ç›® 1ï¼šåº·å¨ç”Ÿå‘½æ¸¸æˆï¼ŒRGB ç‰ˆæœ¬ï¼ï¼ˆA éƒ¨åˆ†æˆªæ­¢æ—¥æœŸä¸º 9 æœˆ 16 æ—¥ï¼ŒB éƒ¨åˆ†æˆªæ­¢æ—¥æœŸä¸º 9 æœˆ 19 æ—¥ï¼‰
Project by Dan Garcia, Justin Yokota, Nikhil Pimpalkhare, and Ryan Thornton
ç”± Dan Garciaã€Justin Yokotaã€Nikhil Pimpalkhare å’Œ Ryan Thornton å…±åŒçš„é¡¹ç›®

Background  èƒŒæ™¯


RIP John Conway (from xkcd)
RIP John Conway (æ¥è‡ª xkcd)

John Horton Conway, one of the worldâ€™s greatest mathematicians, passed away this year due to the coronavirus. One of his many contributions was the famous Game of Life, which you will explore and ultimately implement in this project. Before we begin with that, we first need to introduce a few concepts.
çº¦ç¿°Â·éœé¡¿Â·åº·å¨ï¼Œä¸–ç•Œä¸Šæœ€ä¼Ÿå¤§çš„æ•°å­¦å®¶ä¹‹ä¸€ï¼Œä»Šå¹´å› æ–°å† ç—…æ¯’å»ä¸–ã€‚ä»–ä¼—å¤šè´¡çŒ®ä¹‹ä¸€å°±æ˜¯è‘—åçš„ç”Ÿå‘½æ¸¸æˆï¼Œä½ å°†åœ¨æœ¬é¡¹ç›®ä¸­æ¢ç´¢å¹¶æœ€ç»ˆå®ç°å®ƒã€‚ä½†åœ¨å¼€å§‹ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆä»‹ç»å‡ ä¸ªæ¦‚å¿µã€‚

Getting Started  å…¥é—¨
Please follow the directions here to get a repository: https://docs.google.com/forms/d/e/1FAIpQLSc_DG6SfY-g9cFDkss7YNj9WoG-CKLMfk3wBCaStm-C8HRmJw/viewform
è¯·æŒ‰ç…§æ­¤å¤„æŒ‡ç¤ºè·å–ä»“åº“ï¼šhttps://docs.google.com/forms/d/e/1FAIpQLSc_DG6SfY-g9cFDkss7YNj9WoG-CKLMfk3wBCaStm-C8HRmJw/viewform

Then, clone your repository locally and add the starter remote
ç„¶åï¼Œå°†ä½ çš„ä»“åº“å…‹éš†åˆ°æœ¬åœ°å¹¶æ·»åŠ åˆå§‹è¿œç¨‹ä»“åº“

$ git clone https://github.com/61c-student/fa20-proj1-GITHUB_USERNAME.git
$ cd fa20-proj1-GITHUB_USERNAME
$ git remote add starter https://github.com/61c-teach/fa20-proj1-starter.git


If you ever want to pull updated starter code, youâ€™d execute the following command:
å¦‚æœæ‚¨æƒ³è·å–æ›´æ–°çš„åˆå§‹ä»£ç ï¼Œæ‚¨å°†æ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼š

$ git pull starter master


PPM Format  PPM æ ¼å¼
In this project, weâ€™ll be working with PPM ASCII files (type P3) with maximum value 255, a simple format for storing images. To understand the PPM format, letâ€™s take a look at an example:
åœ¨è¿™ä¸ªé¡¹ç›®ä¸­ï¼Œæˆ‘ä»¬å°†å¤„ç† PPM ASCII æ–‡ä»¶ï¼ˆç±»å‹ P3ï¼‰ï¼Œå…¶æœ€å¤§å€¼ä¸º 255ï¼Œè¿™æ˜¯ä¸€ç§ç®€å•çš„å›¾åƒå­˜å‚¨æ ¼å¼ã€‚ä¸ºäº†ç†è§£ PPM æ ¼å¼ï¼Œè®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªä¾‹å­ï¼š

P3
4 5
255
  0   0   0     0   0   0     0   0   0     0   0   0
255 255 255   255 255 255   255 255 255     0   0   0
  0   0   0     0   0   0     0   0   0     0   0   0
  0   0   0     0   0   0     0   0   0     0   0   0
  0   0   0     0   0   0     0   0   0     0   0   0



The first line of the header, â€œP3â€, tells us that this is a PPM file of format P3 (there happen to be 5 other formats).
å¤´éƒ¨ç¬¬ä¸€è¡Œâ€œP3â€å‘Šè¯‰æˆ‘ä»¬è¿™æ˜¯ä¸€ä¸ª P3 æ ¼å¼çš„ PPM æ–‡ä»¶ï¼ˆæ°å¥½æœ‰ 5 ç§å…¶ä»–æ ¼å¼ï¼‰ã€‚

The second line tells us the width and the height of our image. In this case, our image is 4 pixels wide and 5 pixels tall.
ç¬¬äºŒè¡Œå‘Šè¯‰æˆ‘ä»¬å›¾åƒçš„å®½åº¦å’Œé«˜åº¦ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬çš„å›¾åƒå®½ 4 åƒç´ ï¼Œé«˜ 5 åƒç´ ã€‚

The final line of the header, â€œ255â€, gives us the scale with which we are describing colors. In this case, color values will range from 0 to 255.
å¤´éƒ¨æœ€åä¸€è¡Œâ€œ255â€ç»™å‡ºäº†æˆ‘ä»¬æè¿°é¢œè‰²çš„æ¯”ä¾‹ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œé¢œè‰²å€¼å°†åœ¨ 0 åˆ° 255 ä¹‹é—´ã€‚

The rest of the file describes the actual pixels in the image - each pixel is described by three numbers, representing the red, green, and blue values in that pixel. The content in the body of the file confirms the information in the header: since each pixel needs 3 numbers, we have 4 pixels per row and 5 rows.
æ–‡ä»¶å…¶ä½™éƒ¨åˆ†æè¿°äº†å›¾åƒä¸­çš„å®é™…åƒç´ â€”â€”æ¯ä¸ªåƒç´ ç”±ä¸‰ä¸ªæ•°å­—æè¿°ï¼Œåˆ†åˆ«ä»£è¡¨è¯¥åƒç´ ä¸­çš„çº¢ã€ç»¿ã€è“å€¼ã€‚æ–‡ä»¶æ­£æ–‡ä¸­çš„å†…å®¹ç¡®è®¤äº†å¤´éƒ¨ä¿¡æ¯ï¼šç”±äºæ¯ä¸ªåƒç´ éœ€è¦ 3 ä¸ªæ•°å­—ï¼Œå› æ­¤æ¯è¡Œæœ‰ 4 ä¸ªåƒç´ ï¼Œå…± 5 è¡Œã€‚

The command convert will be very useful for file manipulations to convert between .ppm format and more standard formats. convert is preinstalled on the hives, and can change between file formats.
å‘½ä»¤ convert å°†éå¸¸é€‚ç”¨äºæ–‡ä»¶æ“ä½œï¼Œç”¨äºåœ¨.ppm æ ¼å¼å’Œæ›´æ ‡å‡†çš„æ ¼å¼ä¹‹é—´è¿›è¡Œè½¬æ¢ã€‚ convert é¢„è£…åœ¨èœ‚å·¢ä¸Šï¼Œå¯ä»¥æ›´æ”¹æ–‡ä»¶æ ¼å¼ã€‚

The command convert -compress none glider.png glider.ppm can convert a png to a PPM P3 format, albeit with a different spacing convention than the one we will be using in this project. Similarly, the command convert glider.ppm glider.png can be used to convert a ppm back to a png. This can be useful for debugging purposes, and seeing the actual image files.
å‘½ä»¤ convert -compress none glider.png glider.ppm å¯ä»¥å°† png è½¬æ¢ä¸º PPM P3 æ ¼å¼ï¼Œå°½ç®¡å…¶é—´è·çº¦å®šä¸æˆ‘ä»¬åœ¨æ­¤é¡¹ç›®ä¸­ä½¿ç”¨çš„ä¸åŒã€‚ç±»ä¼¼åœ°ï¼Œå‘½ä»¤ convert glider.ppm glider.png å¯ç”¨äºå°† ppm è½¬æ¢å› pngã€‚è¿™å¯¹äºè°ƒè¯•ç›®çš„å’ŒæŸ¥çœ‹å®é™…å›¾åƒæ–‡ä»¶å¯èƒ½å¾ˆæœ‰ç”¨ã€‚

File I/O  æ–‡ä»¶ I/O
In this project, you will need to read in PPM files and convert them to a form that you can use to accomplish the various tasks you are given. To help you get started, we have provided some useful struct definitions in imageloader.h:
åœ¨è¿™ä¸ªé¡¹ç›®ä¸­ï¼Œä½ éœ€è¦è¯»å– PPM æ–‡ä»¶å¹¶å°†å®ƒä»¬è½¬æ¢ä¸ºä½ å¯ä»¥ç”¨æ¥å®Œæˆæ‰€ç»™ä»»åŠ¡çš„æ ¼å¼ã€‚ä¸ºäº†å¸®åŠ©ä½ å¼€å§‹ï¼Œæˆ‘ä»¬åœ¨ imageloader.h ä¸­æä¾›äº†ä¸€äº›æœ‰ç”¨çš„ç»“æ„å®šä¹‰ï¼š

typedef struct Color 
{
    uint8_t R;
    uint8_t G;
    uint8_t B;
} Color;

typedef struct Image
{
    Color **image;
    uint32_t rows;
    uint32_t cols;
} Image;


Each pixel in a given PPM file should be stored as a Color, and each overall image should be stored as an Image. The attributes (R, G, B) for Color should respectively be the red, green, and blue values for the stored pixel. For Image, the rows and cols attributes should store the dimensions of the image. The image attribute should be a list of Color*, where each Color* stores the color of a single pixel. You are free to choose any implementation that fits this, but we recommend storing pixels in row-major order. In row-major order, we store pixels in â€œreading orderâ€, from top to bottom, left to right. This is effectively the same order that pixels are written in a .ppm file, so this will greatly simplify your code.
åœ¨ç»™å®šçš„ PPM æ–‡ä»¶ä¸­çš„æ¯ä¸ªåƒç´ åº”è¯¥å­˜å‚¨ä¸º Color ï¼Œè€Œæ•´ä¸ªå›¾åƒåº”è¯¥å­˜å‚¨ä¸º Image ã€‚ Color çš„å±æ€§ï¼ˆRï¼ŒGï¼ŒBï¼‰åº”è¯¥åˆ†åˆ«æ˜¯å­˜å‚¨çš„åƒç´ çš„çº¢ã€ç»¿ã€è“å€¼ã€‚å¯¹äº Image ï¼Œrows å’Œ cols å±æ€§åº”è¯¥å­˜å‚¨å›¾åƒçš„å°ºå¯¸ã€‚image å±æ€§åº”è¯¥æ˜¯ä¸€ä¸ª Color* çš„åˆ—è¡¨ï¼Œå…¶ä¸­æ¯ä¸ª Color* å­˜å‚¨å•ä¸ªåƒç´ çš„é¢œè‰²ã€‚ä½ å¯ä»¥è‡ªç”±é€‰æ‹©ä»»ä½•ç¬¦åˆè¿™ä¸ªè¦æ±‚çš„å®ç°æ–¹å¼ï¼Œä½†æˆ‘ä»¬æ¨èä»¥è¡Œä¸ºä¸»åºå­˜å‚¨åƒç´ ã€‚åœ¨è¡Œä¸ºä¸»åºä¸­ï¼Œæˆ‘ä»¬æŒ‰â€œé˜…è¯»é¡ºåºâ€å­˜å‚¨åƒç´ ï¼Œä»ä¸Šåˆ°ä¸‹ï¼Œä»å·¦åˆ°å³ã€‚è¿™å®é™…ä¸Šä¸.ppm æ–‡ä»¶ä¸­åƒç´ çš„å†™å…¥é¡ºåºç›¸åŒï¼Œå› æ­¤è¿™å°†å¤§å¤§ç®€åŒ–ä½ çš„ä»£ç ã€‚

For file I/O, we recommend using fopen and fclose for file management and fscanf for actually reading data from the file. Here is an annotated example of using these three functions:
å¯¹äºæ–‡ä»¶ I/Oï¼Œæˆ‘ä»¬æ¨èä½¿ç”¨ fopen å’Œ fclose è¿›è¡Œæ–‡ä»¶ç®¡ç†ï¼Œä»¥åŠä½¿ç”¨ fscanf å®é™…ä»æ–‡ä»¶ä¸­è¯»å–æ•°æ®ã€‚ä»¥ä¸‹æ˜¯ä½¿ç”¨è¿™ä¸‰ä¸ªå‡½æ•°çš„æ³¨é‡Šç¤ºä¾‹ï¼š

// fopen opens a file pointer to the "diary.txt" file.
// The "r" indicates that the file should be opened in "read mode".
// Other modes are detailed in the documentation linked above.
FILE *fp = fopen("diary.txt", "r");

// fscanf reads the first word and first number from the given file pointer into buf and num, respectively.
// The second argument is a string format, specifying what exactly fscanf should be reading from the file pointer.
// More options can for the string format can be found in the documentation linked above,
// but you may need to Google to figure out how to scan in specific types.
char buf[20];
int num;
fscanf(fp, "%s %d", buf, &num);

// fclose simply closes the file pointer after we're done with it.
// This frees the memory that fopen allocated for the file.
// This is also a necessary step whenever we are writing to a file:
// without closing the pointer, you may lose the last few lines
// you want to write.
fclose(fp);


Part A1
In imageloader.c, write the functions readData, writeData, and freeImage, which will be used to convert between the Image struct and .ppm files. readData should read an Image struct from a .ppm file, writeData should write an Image struct in its PPM format to standard output, and freeImage should free an Image object. We have included all needed libraries; for this project, you may not add additional include statements.
åœ¨ imageloader.c ä¸­ï¼Œç¼–å†™ç”¨äºåœ¨ Image ç»“æ„ä½“å’Œ .ppm æ–‡ä»¶ä¹‹é—´è¿›è¡Œè½¬æ¢çš„ readData ã€ writeData å’Œ freeImage å‡½æ•°ã€‚ readData åº”è¯¥ä» .ppm æ–‡ä»¶ä¸­è¯»å– Image ç»“æ„ä½“ï¼Œ writeData åº”è¯¥å°†å…¶ PPM æ ¼å¼çš„ Image ç»“æ„ä½“å†™å…¥æ ‡å‡†è¾“å‡ºï¼Œè€Œ freeImage åº”è¯¥é‡Šæ”¾ Image å¯¹è±¡ã€‚æˆ‘ä»¬å·²ç»åŒ…å«äº†æ‰€æœ‰éœ€è¦çš„åº“ï¼›å¯¹äºè¿™ä¸ªé¡¹ç›®ï¼Œä½ ä¸å¯ä»¥æ·»åŠ é¢å¤–çš„ include è¯­å¥ã€‚

We have provided a sanity test for this part in imageloadertester.c. Running make imageloader will compile imageloader and run the test. make imagememcheck will run a check on memory leaks.
æˆ‘ä»¬åœ¨ imageloadertester.c ä¸­ä¸ºè¿™ä¸€éƒ¨åˆ†æä¾›äº†ä¸€ä¸ªåˆç†æ€§æµ‹è¯•ã€‚è¿è¡Œ make imageloader å°†ä¼šç¼–è¯‘ imageloader å¹¶è¿è¡Œæµ‹è¯•ã€‚ make imagememcheck å°†ä¼šè¿›è¡Œå†…å­˜æ³„æ¼æ£€æŸ¥ã€‚

Output Correctness  è¾“å‡ºæ­£ç¡®æ€§
In order for your project to be autograded properly, it must follow these output guidelines:
ä¸ºäº†ä½¿ä½ çš„é¡¹ç›®èƒ½å¤Ÿæ­£ç¡®åœ°è¿›è¡Œè‡ªåŠ¨è¯„åˆ†ï¼Œå®ƒå¿…é¡»éµå¾ªä»¥ä¸‹è¾“å‡ºæŒ‡å—ï¼š

The first lines in each of the output files MUST follow this format:
æ¯ä¸ªè¾“å‡ºæ–‡ä»¶çš„ç¬¬ä¸€è¡Œå¿…é¡»éµå¾ªä»¥ä¸‹æ ¼å¼ï¼š

â€¦where [cols] is the number of cols, and [rows] is the number of rows.
â€¦å…¶ä¸­[cols]æ˜¯åˆ—æ•°ï¼Œ[rows]æ˜¯è¡Œæ•°ã€‚

The remainder of the file is your image data, which have to follow the following rules.
æ–‡ä»¶å…¶ä½™éƒ¨åˆ†æ˜¯ä½ çš„å›¾åƒæ•°æ®ï¼Œå¿…é¡»éµå¾ªä»¥ä¸‹è§„åˆ™ã€‚

Each of the R, G and B values should be formatted to have 3 characters, with a space between them.
æ¯ä¸ª Rã€G å’Œ B å€¼åº”æ ¼å¼åŒ–ä¸º 3 ä¸ªå­—ç¬¦ï¼Œå®ƒä»¬ä¹‹é—´åº”æœ‰ä¸€ä¸ªç©ºæ ¼ã€‚
There should be three spaces between columns.
åˆ—ä¹‹é—´åº”æœ‰ä¸‰ä¸ªç©ºæ ¼ã€‚
Do not have any extraneous whitespace characters at the end of the row.
è¡Œå°¾ä¸åº”æœ‰ä»»ä½•å¤šä½™çš„ç©ºç™½å­—ç¬¦ã€‚
All rows end with a newline character.
æ‰€æœ‰è¡Œéƒ½ä»¥æ¢è¡Œç¬¦ç»“æŸã€‚
After your program exits, the UNIX prompt should start on a new line and not on the same line (There should be a new line at the end of your file).
å½“ä½ çš„ç¨‹åºé€€å‡ºåï¼ŒUNIX æç¤ºç¬¦åº”ä»æ–°çš„ä¸€è¡Œå¼€å§‹ï¼Œè€Œä¸æ˜¯åœ¨åŒä¸€è¡Œï¼ˆæ–‡ä»¶æœ«å°¾åº”æœ‰æ¢è¡Œç¬¦ï¼‰ã€‚
You may assume for our autograder tests that the input file follows this exact format; however, note that some of our examples in testInputs and most converters will have different amounts of whitespace between pixels and the end of lines. If you use fscanf, though, your code should be able to handle different amounts of whitespace between pixels.
ä½ å¯ä»¥å‡è®¾æˆ‘ä»¬çš„è‡ªåŠ¨è¯„åˆ†å™¨æµ‹è¯•ä¸­è¾“å…¥æ–‡ä»¶éµå¾ªæ­¤ç¡®åˆ‡æ ¼å¼ï¼›ç„¶è€Œï¼Œè¯·æ³¨æ„ï¼Œæˆ‘ä»¬çš„æµ‹è¯•è¾“å…¥ä¸­çš„æŸäº›ç¤ºä¾‹ä»¥åŠå¤§å¤šæ•°è½¬æ¢å™¨åœ¨åƒç´ ä¹‹é—´å’Œè¡Œå°¾çš„ç©ºç™½å­—ç¬¦æ•°é‡ä¼šæœ‰æ‰€ä¸åŒã€‚ä½†æ˜¯ï¼Œå¦‚æœä½ ä½¿ç”¨ fscanfï¼Œä½ çš„ä»£ç åº”è¯¥èƒ½å¤Ÿå¤„ç†åƒç´ ä¹‹é—´çš„ä¸åŒæ•°é‡çš„ç©ºç™½å­—ç¬¦ã€‚
For an example of a properly formatted PPM file, look at testInputs/JohnConway.ppm.
è¦æŸ¥çœ‹ä¸€ä¸ªæ ¼å¼æ­£ç¡®çš„ PPM æ–‡ä»¶çš„ç¤ºä¾‹ï¼Œè¯·æŸ¥çœ‹ testInputs/JohnConway.ppm ã€‚

Part A2
Now that weâ€™ve written our imageloader, letâ€™s use it for something! Steganography is the process of hiding a message in an image or similar file. In this exercise, we will explore one way in which we can hide a message. While most images have 8 bits worth of data for each RGB channel, the human eye canâ€™t easily see differences in the bottom 4 bits. We can thus hide information in the bottom bits of an image. Weâ€™ve hidden a secret message in the test input testInputs/JohnConway.ppm by modifying the least significant bit of every pixelâ€™s B value. If a pixel in our secret message is supposed to be black, we made that bit a 0. If a pixel is supposed to be white, we made that bit a 1. Here is an example:
ç°åœ¨æˆ‘ä»¬å·²ç»ç¼–å†™äº†æˆ‘ä»¬çš„ imageloaderï¼Œè®©æˆ‘ä»¬ç”¨å®ƒæ¥åšä»€ä¹ˆï¼éšå†™æœ¯æ˜¯åœ¨å›¾åƒæˆ–ç±»ä¼¼æ–‡ä»¶ä¸­éšè—æ¶ˆæ¯çš„è¿‡ç¨‹ã€‚åœ¨è¿™ä¸ªç»ƒä¹ ä¸­ï¼Œæˆ‘ä»¬å°†æ¢ç´¢ä¸€ç§éšè—æ¶ˆæ¯çš„æ–¹æ³•ã€‚è™½ç„¶å¤§å¤šæ•°å›¾åƒçš„æ¯ä¸ª RGB é€šé“éƒ½æœ‰ 8 ä½æ•°æ®ï¼Œä½†äººçœ¼å¾ˆéš¾çœ‹åˆ°æœ€ä½ 4 ä½ä¹‹é—´çš„å·®å¼‚ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å›¾åƒçš„æœ€ä½ä½ä¸­éšè—ä¿¡æ¯ã€‚æˆ‘ä»¬å·²ç»é€šè¿‡ä¿®æ”¹æ¯ä¸ªåƒç´ çš„ B å€¼çš„æœ€ä½æœ‰æ•ˆä½ï¼Œåœ¨æµ‹è¯•è¾“å…¥ testInputs/JohnConway.ppm ä¸­éšè—äº†ä¸€æ¡ç§˜å¯†æ¶ˆæ¯ã€‚å¦‚æœæˆ‘ä»¬çš„ç§˜å¯†æ¶ˆæ¯ä¸­çš„æŸä¸ªåƒç´ åº”è¯¥æ˜¯é»‘è‰²çš„ï¼Œæˆ‘ä»¬å°±å°†è¯¥ä½è®¾ç½®ä¸º 0ã€‚å¦‚æœåƒç´ åº”è¯¥æ˜¯ç™½è‰²çš„ï¼Œæˆ‘ä»¬å°±å°†è¯¥ä½è®¾ç½®ä¸º 1ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªç¤ºä¾‹ï¼š

P3
2 2
255
  29  83  36      45  64  57   
 188 229 201     123 162 184   


In order to decode the secret message in this image, we need to consider the bit representation of the blue value for each pixel:
ä¸ºäº†è§£ç è¿™å¼ å›¾åƒä¸­çš„ç§˜å¯†ä¿¡æ¯ï¼Œæˆ‘ä»¬éœ€è¦è€ƒè™‘æ¯ä¸ªåƒç´ è“è‰²å€¼çš„äºŒè¿›åˆ¶è¡¨ç¤ºï¼š

0b0010 0100	0b0011 1001
0b1100 1001	0b1011 1000
Now, we can look at just the rightmost bit in order to determine whether that pixel in the hidden message is white or black. Given that white is (255, 255, 255) and black is (0, 0, 0), we know what our output PPM should be:
ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥æŸ¥çœ‹æœ€å³è¾¹çš„ä½ï¼Œä»¥ç¡®å®šéšè—ä¿¡æ¯ä¸­çš„é‚£ä¸ªåƒç´ æ˜¯ç™½è‰²è¿˜æ˜¯é»‘è‰²ã€‚è€ƒè™‘åˆ°ç™½è‰²æ˜¯ (255, 255, 255)ï¼Œé»‘è‰²æ˜¯ (0, 0, 0)ï¼Œæˆ‘ä»¬çŸ¥é“æˆ‘ä»¬çš„è¾“å‡º PPM åº”è¯¥æ˜¯ä»€ä¹ˆï¼š

P3
2 2
255
  0   0   0   255 255 255   
255 255 255     0   0   0   


In steganography.c, implement evaluateOnePixel, steganography, and main and decode our secret message. The purpose for each of these functions is written in the docstrings. Your program should take in a .ppm file as input and print out a corresponding â€œdecodedâ€ image.
åœ¨ steganography.c ä¸­ï¼Œå®ç° evaluateOnePixel ã€ steganography å’Œ main ï¼Œå¹¶è§£ç æˆ‘ä»¬çš„ç§˜å¯†ä¿¡æ¯ã€‚æ¯ä¸ªå‡½æ•°çš„ç”¨é€”åœ¨ docstrings ä¸­æœ‰è¯´æ˜ã€‚ä½ çš„ç¨‹åºåº”è¾“å…¥ä¸€ä¸ª.ppm æ–‡ä»¶ï¼Œå¹¶è¾“å‡ºç›¸åº”çš„â€œè§£ç â€å›¾åƒã€‚

make steganography will compile steganography and output the result in studentOutputs/secretmessage.ppm. If your code worked, you should see a â€œsecret messageâ€. make steganographymemcheck can also be used to test for memory leaks.
make steganography å°†ä¼šç¼–è¯‘éšå†™æœ¯å¹¶è¾“å‡ºç»“æœåˆ° studentOutputs/secretmessage.ppmã€‚å¦‚æœä½ çš„ä»£ç è¿è¡Œæ­£å¸¸ï¼Œä½ åº”è¯¥èƒ½çœ‹åˆ°â€œç§˜å¯†ä¿¡æ¯â€ã€‚ make steganographymemcheck ä¹Ÿå¯ä»¥ç”¨æ¥æ£€æµ‹å†…å­˜æ³„æ¼ã€‚

Submitting Your Code  æäº¤ä½ çš„ä»£ç 
Please submit using Gradescope to Project 1A, using the GitHub submission option to ensure that your files are in the right place.
è¯·ä½¿ç”¨ Gradescope æäº¤åˆ° Project 1Aï¼Œä½¿ç”¨ GitHub æäº¤é€‰é¡¹ä»¥ç¡®ä¿ä½ çš„æ–‡ä»¶åœ¨æ­£ç¡®çš„ä½ç½®ã€‚

REMEMBER: the grading will be done almost entirely by automated scripts. We will be only using your imageloader.c and steganography.c files when grading! Your output must exactly match the specified format, making correctness the primary goal of this project. Upon submission, the autograder will give you the result of a basic sanity test but will not give you your complete grade. Rather, you are responsible for developing any tests you need to make sure that you meet the requirements of the project. We deliberately did not include a more comprehensive test. We want you to practice writing your own tests!
è®°ä½ï¼šè¯„åˆ†å‡ ä¹å°†å®Œå…¨ç”±è‡ªåŠ¨è„šæœ¬å®Œæˆã€‚æˆ‘ä»¬åœ¨è¯„åˆ†æ—¶åªä¼šä½¿ç”¨ä½ çš„ imageloader.c å’Œ steganography.c æ–‡ä»¶ï¼ä½ çš„è¾“å‡ºå¿…é¡»å®Œå…¨åŒ¹é…æŒ‡å®šçš„æ ¼å¼ï¼Œä½¿æ­£ç¡®æ€§æˆä¸ºè¿™ä¸ªé¡¹ç›®çš„ä¸»è¦ç›®æ ‡ã€‚æäº¤åï¼Œè‡ªåŠ¨è¯„åˆ†å™¨å°†ç»™ä½ ä¸€ä¸ªåŸºæœ¬çš„åˆç†æ€§æµ‹è¯•ç»“æœï¼Œä½†ä¸ä¼šç»™ä½ å®Œæ•´çš„æˆç»©ã€‚ç›¸åï¼Œä½ éœ€è¦è´Ÿè´£å¼€å‘ä»»ä½•ä½ éœ€è¦çš„æµ‹è¯•æ¥ç¡®ä¿ä½ æ»¡è¶³é¡¹ç›®çš„éœ€æ±‚ã€‚æˆ‘ä»¬æ•…æ„æ²¡æœ‰åŒ…å«ä¸€ä¸ªæ›´å…¨é¢çš„æµ‹è¯•ã€‚æˆ‘ä»¬å¸Œæœ›ä½ ç»ƒä¹ ç¼–å†™è‡ªå·±çš„æµ‹è¯•ï¼

Part B  B éƒ¨åˆ†
The Game of Life  ç”Ÿå‘½æ¸¸æˆ
The Game of Life is usually played on a bitmap (black and white) image over many timesteps, in which each pixel (or bit) is either 1 (alive) or 0 (dead). The original rules for the Game of Life are reprinted below:
ç”Ÿå‘½æ¸¸æˆé€šå¸¸åœ¨ä½å›¾ï¼ˆé»‘ç™½ï¼‰å›¾åƒä¸Šï¼Œç»è¿‡å¤šä¸ªæ—¶é—´æ­¥è¿›è¡Œï¼Œå…¶ä¸­æ¯ä¸ªåƒç´ ï¼ˆæˆ–ä½ï¼‰è¦ä¹ˆæ˜¯ 1ï¼ˆå­˜æ´»ï¼‰ï¼Œè¦ä¹ˆæ˜¯ 0ï¼ˆæ­»äº¡ï¼‰ã€‚ç”Ÿå‘½æ¸¸æˆçš„åŸè§„åˆ™å¦‚ä¸‹é‡å°ï¼š

Any live cell with two or three live neighbours (in the surrounding 8 cells) survives to the next generation.
Any dead cell with three live neighbours becomes a live cell in the next generation.
All other live cells die in the next generation. Similarly, all other dead cells stay dead.
Letâ€™s make a table to clarify how weâ€™re going to encode this rule as a hexadecimal number:

If my state is...	alive (1)	dead (0)
And the number of alive neighbors is...	8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0	
Then the next state I will be...	0 | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0	
Converting the 18 bits above to a hexadecimal number	0b00 0001 1000 0000 1000
0x1808	
By specifying a hexadecimal number between 0x0 and 0x3FFFF, you can have your simulation run any Game of Life variant, not just the usual rule of 0x1808. Here is a table of interesting Life-like rules, converted to our rule format:

Hex rule	Name	Description
0x1808	Life	Highly complex behavior.
0x154AA	Replicator	Edward Fredkin's replicating automaton: every pattern is eventually replaced by multiple copies of itself.
0x4	Seeds	All patterns are phoenixes, meaning that every live cell immediately dies, and many patterns lead to explosive chaotic growth. However, some engineered patterns with complex behavior are known.
0x2024	Unnamed	This rule supports a small self-replicating pattern which, when combined with a small glider pattern, causes the glider to bounce back and forth in a pseudorandom walk.
0x3FE08	Life without Death	Also known as Inkspot or Flakes. Cells that become alive never die. It combines chaotic growth with more structured ladder-like patterns that can be used to simulate arbitrary Boolean circuits.
0x3018	34 Life	Was initially thought to be a stable alternative to Life, until computer simulation found that larger patterns tend to explode. Has many small oscillators and spaceships.
0x3C1E8	Diamoeba	Forms large diamonds with chaotically fluctuating boundaries.
0x4C48	2x2	If a pattern is composed of 2x2 blocks, it will continue to evolve in the same form; grouping these blocks into larger powers of two leads to the same behavior, but slower. Has complex oscillators of high periods as well as a small glider.
0x1848	HighLife	Similar to Life but with a small self-replicating pattern.
0x3B1C8	Day & Night	Symmetric under on-off reversal. Has engineered patterns with highly complex behavior.
0x6948	Morley	Named after Stephen Morley; also called Move. Supports very high-period and slow spaceships.
0x3D1D0	Anneal	Also called the twisted majority rule. Symmetric under on-off reversal. Approximates the curve-shortening flow on the boundaries between live and dead cells.
Blinker Example
Blinker example

The most common â€œoscilatorâ€ for the standard rules is the Blinker. It is a line of pixels 3 high that flips and flops between being horizontal and vertical. Hereâ€™s the contents of blinkerH.ppm, which places the horizontal blinker with its center one away from the top left corner of a 4x5 image:

$ cat blinkerH.ppm
P3
4 5
255
  0   0   0     0   0   0     0   0   0     0   0   0
255 255 255   255 255 255   255 255 255     0   0   0
  0   0   0     0   0   0     0   0   0     0   0   0
  0   0   0     0   0   0     0   0   0     0   0   0
  0   0   0     0   0   0     0   0   0     0   0   0


â€¦and hereâ€™s how weâ€™d run it through our system to generate the next iteration of the Game of Life, with standard rules:

$ ./gameOfLife blinkerH.ppm 0x1808
P3
4 5
255
  0   0   0   255 255 255     0   0   0     0   0   0
  0   0   0   255 255 255     0   0   0     0   0   0
  0   0   0   255 255 255     0   0   0     0   0   0
  0   0   0     0   0   0     0   0   0     0   0   0
  0   0   0     0   0   0     0   0   0     0   0   0


â€¦if we save that output into a file (blinkerV.ppm), weâ€™d see that we get our original image back again on the next iteration:

$ ./gameOfLife blinkerH.ppm 0x1808 > blinkerV.ppm
$ ./gameOfLife blinkerV.ppm 0x1808
P3
4 5
255
  0   0   0     0   0   0     0   0   0     0   0   0
255 255 255   255 255 255   255 255 255     0   0   0
  0   0   0     0   0   0     0   0   0     0   0   0
  0   0   0     0   0   0     0   0   0     0   0   0
  0   0   0     0   0   0     0   0   0     0   0   0


Multiple Colors
To expand upon the standard bitmap Game of Life, your implementation will read in an ASCII full-color (24-bit) image and the rules for the variant of the Game of Life you wish to simulate, and print (to STDOUT) another ASCII full-color image of one iteration of the simulation. What makes this neat is that youâ€™ll be running 24 simultaneous Game of Life simulations, one for every â€œbit planeâ€ of the 24-bit (8 Red, 8 Blue, and 8 Green) image.



In this grayscale example, you can see that there are multiple independent Game of Life simulations occuring simultanously in the same space. The seen objects do not interact with each other because they each are being simulated at a different bit.



When we add on different red, green and blue values, your simulation can become incredibly complex and visually interesting. In the above example, you can notice that multiple different structures and colors are able to merge and combine with each others without interaction, or with interaction in complex ways.

Assignment
Itâ€™s time for the big event! You will be implementing the Game of Life in C!

Your program must be usable in the following way:

$ ./gameOfLife [file] [rule]


â€¦where **_[file]_** is a PPM ASCII file, and **_[rule]_** is a hexadecimal encoding of the generalized Game of Life rules. If you do not receive the correct number of input arguments, you should print the following usage string:

$ ./gameOfLife
    usage: ./gameOfLife filename rule
    filename is an ASCII PPM file (type P3) with maximum value 255.
    rule is a hex number beginning with 0x; Life is 0x1808.


Otherwise, you may assume that the rule is a hexadecimal number between 0x00000 and 0x3FFFF, and that the input file exists and is valid.

In gameoflife.c, implement evaluateOneCell, life, and main. You may notice that the structure of this file is very similar to steganography.c - this is on purpose! You should be able to keep your code largely the same, and make the brunt of the modifications in evaluateOneCell. Note that we treat the top row as adjacent to the bottom row, and the left column as adjacent to the right column.

Testing for Correctness
We are providing you with an Oracle for this assignment to help you check your solutions. It will accept the standard arguments as described in the specification above. You can run the oracle using the following command, where filename and rule are as in gameOfLife. If you have other questions, you are welcome to post them on Piazza.

$ oracleOfLife [filename] [rule]


make gameoflife will compile your code into the executable gameOfLife. This does not run any tests, though, so you will need to run them yourself, either directly, or through frames.csh. We have provided with the starter code the result of running GliderGuns with rule 0x1808 over 100 generations, but it is important to note that this test is not comprehensive (for example, it doesnâ€™t check if your code works on the boundary); you will thus need to make your own tests to confirm that your code works. make gameoflifememcheck runs a quick memory check on gameoflife; for the exact commands run, you can open the Makefile with any text editor and see what lines of UNIX commands are being performed.

Making An Animation
Since the Game of Life is designed to run for many generations, we have provided a shell script that will run GameOfLife repeatedly over multiple generations. To use the script, run:

$ ./frames.csh [prefix of ppm file in testInputs] [rule in hex] [number of frames]


Note that this is designed to be run on the hive machines, and is only designed to work with 90,000 frames or less. If it fails due to permission denied, try running the command:

The frames will be outputted in studentOutputs/[prefix]. To regenerate frames, you will need to delete the folder of previously generated images. frames.csh will also convert the ppms into a gif, but you may want to change certain aspects of this conversion like the scale of the drawing or the delay between frames.

The conversion is done with a line of the following form:

$ convert -delay [delay between frames] -loop 0 -scale [scale]% studentOutputs/[name]/*.ppm [name].gif


For example, to create a 100 frame gif using testInputs/GliderGuns.ppm as an initial state and 0x1808 as the ruleset, run:

$ ./frames.csh GliderGuns 0x1808 100


This will create a gif equivalent to running the command:

$ convert -delay 20 -loop 0 -scale 400% studentOutputs/GliderGuns/*.ppm GliderGuns.gif


Submitting Your Code
Please submit using Gradescope to Project 1B, using the GitHub submission option to ensure that your files are in the right place.

REMEMBER: the grading will be done almost entirely by automated scripts. We will be only using your imageloader.c and gameoflife.c file when grading! Your output must exactly match the specified format, making correctness the primary goal of this project. Upon submission, the autograder will give you the result of a basic sanity test but will not give you your complete grade. Rather, you are responsible for developing any tests you need to make sure that you meet the requirements of the project. We deliberately did not include a more comprehensive test. We want you to practice writing your own tests!

Congratulations!
Youâ€™ve successfully completed Project 1 for CS61C! Please feel free to experiment with different initial states and rulesets, and do post to Piazza if you discover something interesting!

explodingconway.mp4: 7.1MB

(WARNING: This video may potentially trigger seizures for people with photosensitive epilepsy. Viewer discretion is advised)

Your browser does not support this video

Previous
Lab11
Next
Project2
Background  èƒŒæ™¯
Getting Started  å…¥é—¨æŒ‡å—
PPM Format  PPM æ ¼å¼
File I/O  æ–‡ä»¶ I/O
Part A1
Output Correctness  è¾“å‡ºæ­£ç¡®æ€§
Part A2
Submitting Your Code  æäº¤æ‚¨çš„ä»£ç 
Part B  éƒ¨åˆ† B
The Game of Life
ç”Ÿå‘½æ¸¸æˆ
Blinker Example  é—ªçƒå™¨ç¤ºä¾‹
Multiple Colors  å¤šç§é¢œè‰²
Assignment  ä»»åŠ¡
Testing for Correctness  æµ‹è¯•æ­£ç¡®æ€§
Making An Animation  åˆ¶ä½œåŠ¨ç”»
Submitting Your Code  æäº¤ä½ çš„ä»£ç 
Congratulations!  æ­å–œï¼

CSå­¦ä¹ ç¤¾åŒº
è·¯çº¿å›¾
ç¤¾åŒº
Discord
æèµ 
æèµ æˆ‘ä»¬
Copyleft Â© 2025 My Project, Inc. Built with Docusaurus.
Skip to main content
è·³è½¬åˆ°ä¸»è¦å†…å®¹
ğŸ‰ï¸ğŸ‰ï¸ğŸ‰ï¸è¯¾ç¨‹æ–‡æ¡£æ±‰åŒ–å·¥ä½œæ­£åœ¨è¿›è¡Œä¸­ ğŸ‰ï¸ğŸ‰ï¸ å­¦ä¹ äº¤æµç¾¤è¯·åˆ° ç¤¾åŒºé¡µé¢ æŸ¥çœ‹å…¥ç¾¤æ–¹å¼ ğŸ‰ï¸ğŸ‰ï¸ğŸ‰ï¸
TeachYourselfCS
TeachYourselfCS
è·¯çº¿å›¾
è¯¾ç¨‹èµ„æº
åšå®¢
ç¤¾åŒº
æèµ æˆ‘ä»¬

å‰è¨€
è·¯çº¿å›¾
è¯¾ç¨‹èµ„æº

cs50x

cs61a

cs61b

cs61c

syllabus-è¯¾ç¨‹å¤§çº²
labs
projects
  é¡¹ç›®
Project1
  é¡¹ç›® 1
Project2
  é¡¹ç›® 2
Project3
  é¡¹ç›® 3
Project4
  é¡¹ç›® 4
MIT 18.01

MIT 18.02

MIT 18.06

MIT 6.042J

cs162

cs144

CMU 15-445

py4e

è¯¾ç¨‹èµ„æºcs61cprojectsProject2
Project2  
Background  èƒŒæ™¯
Part A Due Thursday, October 1st  
Part B Due Monday, October 5th  

At the end of this project you will have written all RISC-V assembly code necessary to run a simple Artificial Neural Network (ANN) on the Venus RISC-V simulator. In part A you will implement the basic operations such as a vector dot product, matrix-matrix multiplication, the argmax and an activation function. In part B you will combine these basic functions in order to load a pretrained network and execute it to classify handwritten digets from the MNIST benchmark set.  

Objectives  ç›®æ ‡
TSWBAT (â€œThe Student Will Be Able Toâ€) implement numerical computation functions in RISC-V assembly that follow calling the convention.  
TSWBAT call functions in RISC-V assembly.  
TSWBAT write RISC-V assembly programs that utilize the heap and interact with files.  
TSWBAT write a test suite that covers corner cases and automatically checks for the correct operation of the RISC-V functions implemented.  
Getting Started  å…¥é—¨
Please follow the directions here to get a repository: https://docs.google.com/forms/d/e/1FAIpQLSe2JEIVWc1HMV-gadLvrL2jM42Zzf3_S3BixjJluRWB2IToBA/viewform?usp=sf_link.  

Then, clone your repository locally and add the starter remote
ç„¶åï¼Œå°†ä½ çš„ä»“åº“å…‹éš†åˆ°æœ¬åœ°å¹¶æ·»åŠ åˆå§‹è¿œç¨‹ä»“åº“

$ git clone https://github.com/61c-student/fa20-proj2-TEAMNAME.git
$ cd fa20-proj2-TEAMNAME
$ git remote add starter https://github.com/61c-teach/fa20-proj2-starter.git


If you ever want to pull updated starter code, youâ€™d execute the following command:
å¦‚æœæ‚¨æƒ³è·å–æ›´æ–°çš„åˆå§‹ä»£ç ï¼Œæ‚¨å°†æ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼š

$ git pull starter master


Java and Python 3 Setup  
Your computer needs be able to run some Java and Python 3 scripts for this project. Most of your computers should be set up properly from 61A and 61B. If not, these CS61A and CS61B setup instructions should help. You are also welcome to work on the hives.  

Part A: Mathematical Functions  
Due Thursday, October 1st  

In this part, you will implement some of the matrix operations used by neural networks These include a dot product, matrix multiplication, an element-wise rectifier function (ReLU), and an argmax function for vectors. But first we will start with a simple abs function which calculates the absolute value of a given integer.  

General Advice and Grading  
Pay close attention to the function definition in the assembly template.  
Implement all argument checks required and call exit2 to abort with the correct error code.  
Pay close attention to the calling convention.  
While the unit tests will run the calling convention checker there are many errors that the automated check might miss.  
Try to write a unit test for every corner case in the specification that you can think of.  
While the unit tests display how much of your implementation is covered by your tests, 100% coverage of your implementation does not imply that all corner cases of the spec are covered.  
This semester you will be graded on the quality of your tests, for part A, your unit tests should cover 100% of your custom code.  
For part B, we require 100% coverage for read_matrix and write_matrix.  
The autograder will give you the result of a basic sanity test but will not give you your complete grade.  
You are responsible for developing any tests you need to make sure that you meet the requirements of the project.  
Even though we have given you a testing framework which allows for the calling convention feature of Venus to run, we still recommend that you write thorough a calling convention test for each function.  
The autograder is rate limited: each submission consumes a token, you will be given 6 tokens; each token will regenerate after twelve hours; get started early to limit the number of last-minute resubmissions.  
If you do not have a token, that submission will not be gradedâ€“even after the deadline has passed.  
Task 0: Getting Started with the Abs Function  
The Purpose of this section is to get you acquainted with the recommended workflow using the unit testing framework and the Venus simulator to better prepare you to complete this project successfully. Follow along with the video linked below or continue reading the written spec.  

Task 0: Getting Started with the Abs Function Video  

Running Tests  
We want to start by running all the given sanity tests to verify that they fail since we havenâ€™t started implementing anything. In order todo that run the following commands:  

cd unittests
python3 -m unittest unittests.py -v


To see the specific assembly tests that the testing framework has generated cd assembly and view all the different .s test files directly.  

For now letâ€™s remove all the assembly tests and worry just about our tests targeting the Abs function. To remove all tests and rerun just the Abs function tests run the following:  

rm -rf assembly
python3 -m unittest unittests.TestAbs -v


Hint: The command to run the unit tests has two options to keep in mind unittests.<testName> targets a specific suite of tests and -v triggers verbose output.  

Note: The unit tests are using the standard Python unittest library.  

Notice that test_one fails while test_zero passes; now letâ€™s debug this function using the Venus Web Interface!  

Debugging Tests with Venus Web Interface
Using the Venus web interface, we can step through our assembly code and inspect registers to find out why the test_one for the Abs function is failing. As the first step we must first upload our files to the Venus Web Interface

Mounting Repository to Venus Web Interface
Run the following command from your local terminal within the root of your project 2 repository

java -jar tools/venus.jar . -dm


When you run it, you should see a Javalin message, launching the server and listening on http://localhost:6161/ Then run the following command from your Venus Web Interface Terminal.

Note: We recommend using the Chrome browser. Other browsers may work but have not been tested.

This will mount the repository and give you access to all your project files from within the Venus Web Interface to edit, run, and debug! Navigate to the Files tab on Venus to see your repositories contents.

(Alternative) Zipping Files to Upload
Use this in case the file mounting does not work on your computer.

To see full list of commands supported by Venus you can run help, but weâ€™ve included some of the ones related to zipping below

upload: Opens up a window allowing you to pick files from your local machine to upload to Venus
unzip <ZIP_FILENAME>: Unzips a .zip file into the current working directory.
zip <ZIP_FILENAME> <FILENAME_1> <FILENAME_2> ... : Opens up a window allowing you to download a zip file called ZIP_FILE_NAME, which contains all the specified files and/or folders. Folders are added to the zip file recursively.
When uploading files to the Venus web interface, youâ€™ll want to zip ONLY your src, inputs, and unittests/assembly directories locally, use the upload in the Venus terminal to upload that zip file, and then unzip to retrieve all your project files.

Alternatively, you can upload individual files to work with. However, youâ€™ll need to make sure the directory structure is the same as the starter repo, or be prepared to edit the relative paths given to you in the starter code for inputs and .import statements.

Note: We HIGHLY recommend that you regularly copy the changes youâ€™ve made in the Venus web interface to your local machine to save them. If you accidentally close the browser window or run edit before running save, you could lose a large amount of progress if you do not enable â€˜Save on Closeâ€™. This is one of the primary reasons we recommend running with the .jar file for most of your development, and only turning to Venus to debug one specific file at a time.**

Note2: If you do use â€˜Save on Closeâ€™ (which you all should), be aware that there is a limit to the size of its state which it can store (limited by your browsers localStorage). This is why we say you should only upload the specified directories.**

Debugging test_one on Venus Web Interface
Navigate to the Files tab on Venus to see your files, and navigate to the abs.s file in proj2/src/abs.s and click edit.

Then using an ebreak statement set a breakpoint right above the command mv a0, zero

Note: This is one out of two ways to set breakpoints in Venus. The other way is to click on any instruction (besides ebreak) in the simulator view. If you click on an ebreak instruction, it will disable the breakpoint instead. One scenario where this comes in handy is when you added an ebreak inside a loop and - after observing the first few iterations - want to disable it to let the loop finish executing.

Now before running test_one, go back to the Files tab and hit Save on the abs.s file. After saving, navigate to unittests/assembly/TestAbs_test_one_test.s and click VDB. This will launch you into the Simulator tab!

Note: When the editor tab is active, you can also use Ctrl + S to save the open file.

Now using your basic Venus knowledge from lab3 you can run and step through the test to see a0 being overridden from a 1 to a 0.

Editing the Abs Function to pass test_one
Letâ€™s remove the statement mv a0, zero from abs.s and rerun test_one.

Observe that test_one indeed does pass after removing the one line of code; however, the absolute value function is still incorrect! This toy example is to show that your code is only as good as how thorough your test cases are.

Adding More Tests for Abs Function
Letâ€™s add another test to check if the function works with negative values. To do this open the file unittests/unittest.py

Add this test underneath class TestAbs(TestCase)

def test_minus_one(self):
    t = AssemblyTest(self, "abs.s")
    t.input_scalar("a0", -1)
    t.call("abs")
    t.check_scalar("a0", 1)
    t.execute()


Note: By modifying just t.input_scalar and t.check_scalar we can build a brand new test!

Now rerun just the Abs Function tests to verify that this test now fails while test_zero and test_one pass. This is an important step in test driven development to make sure that the tests we wrote fail before implementing the function:

python3 -m unittest unittests.TestAbs -v


Editing Abs Function to pass test_minus_one
Insert the following code into abs.s

    # branch if positive
    bge a0, zero, done
    # invert a if negative
    sub a0, zero, a0


Now all Abs Function tests should pass! Let this be a warning to write good tests and produce well commented code. Happy coding!

Background Knowledge
Matrix Format
In this project, all two-dimensional matrices will be stored as one-dimensional arrays in row-major order. Row-major order stores all values in a row of a matrix consecutively and concatenates all row vectors into a single 1-D array starting from the top-most row. The alternative column-major order stores all values in a column of a matrix consecutively and concatenates all columns vectors into a single 1-D array starting from the left-most column. Our choice of row-major order follows the convention of most C/C++ programs.



Array Strides
The stride of an array is the number of bytes between the beginning of consecutive array elements. So far all arrays we have worked with had unit stride, meaning that there is not gap between consecutive elements and the stride is sizeof(element).

In this project, all strides will be given in multiples of the element size instead of bytes. Thus the unit stride is just 1.

We are going to use the stride to define column vectors in our matrix (stored in row-major order) without having to copy any elements. Since row elements are stored consecutively, a row vector is just an array with unit stride. However, if we want to get the column vector, we need to skip over the end of the current row and the beginning of the next row to get to the next element in the column. Thus the stride will be the number of elements in a row.

Here is a practical example: We have the vector int *a with 3 elements.

If the stride is 1, then our vector elements are *(a), *(a + 1), and *(a + 2), in other words a[0], a[1], and a[2].
However, if our stride is 4, then our elements are at *(a), *(a + 4), and *(a + 8) or in other words a[0], a[4], and a[8].
To summarize: In C code, to access the ith element of a vector int *a with stride s, we use *(a + i * s), or a[i * s]. We leave it up to you to translate this memory access pattern into RISC-V for the dot product in task 3.

Task 1: ReLU
Implement the relu function in src/relu.s which takes in a 1D vector and applies the rectifier function on each element, modifying it in place. This is equivalent to setting every negative value in the vector to 0. Be careful to follow the specification in the header comment in the relu.s file.

Note: Our relu function operates on a 1-D vector, not a 2-D matrix. Since relu works on an element by element basis, independent of the position of that element in the matrix, we are able to treat our 2-D matrix which is stored in row-major format as a 1-D vector.

Hint: You can run the unit test that we provide you for this task by running the following command in the unittest directory:

python3 -m unittest unittests.TestRelu -v


Hint: to achieve 100% test coverage you will need to add your own tests to cover all the corner cases in the spec. Think carefully about every branch in your implementation.

Task 2: ArgMax
The argmax function returns the index of the largest element in a vector. It will be used at the end of our neural network to select the most likely classification.

Implement the argmax function in src/argmax.s which takes in a 1D vector and returns the index of the largest element. Be careful to follow the specification in the header comment in the argmax.s file.

Hint: You can run the unit test that we provide you for this task by running the following command in the unittest directory. Fill in the TODOs in unittests.py to make it work:

python3 -m unittest unittests.TestArgmax -v


Task 3.1: Dot Product
The dot product of two vectors and is defined as , where is the th element of .

Implement the dot function in src/dot.s which takes in two vectors and returns their dot product. Be careful to follow the specification in the header comment in the dot.s file.

Note: This function takes in the stride for each vector as an argument. Make sure youâ€™re considering this when calculating your memory addresses. Consider re-reading the section on array strides in the background materials.

Note: We do not expect you to handle overflow when multiplying. This means you will not need to use the mulh instruction.

Note: keep in mind that - like in C - there is no way for the function to verify that the vector length argument actually matches the size of memory allocated for the vector.

Testing: Dot Product
You can run the unit test that we provide you for this task by running the following command in the unittest directory. Fill in the TODOs in unittests.py to make it work:

python3 -m unittest unittests.TestDot -v


A basic test provides the dot function with two vectors v0 and v1 of size 9 and unit stride. We thus expect the following result:

v0 = [1, 2, 3, 4, 5, 6, 7, 8, 9]
v1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]
dot(v0, v1) = 1 * 1 + 2 * 2 + ... + 9 * 9 = 285


Implement this test using the methods provided by the AssemblyTest class.

Now fill in the test_stride function. What should happen if you change the length of the vectors to 3 and the stride of the second vector v1 to 2, without changing the values in static memory? Now, the vectors contain the following:

v0 = [1, 2, 3]
v1 = [1, 3, 5]
dot(v0, v1) = 1 * 1 + 2 * 3 + 3 * 5 = 22


Note: v1 now has stride 2, so we skip over elements in memory when calculating the dot product. However, the pointer v1 still points to the same place as before: the start of the sequence of integers 1 to 9 in memory.

Hint: as before, you will need to add multiple test to achieve 100% coverage.

Task 3.2: Matrix Multiplication
The matrix multiplication of two matrices and results in the output matrix , where is equal to the dot product of the -th row of and the -ith column of .

Note: If the dimensions of are , and the dimensions of are , then the dimensions of must be .

Note: Unlike integer multiplication, matrix multiplication is not commutative, .

Implement the matmul function in src/matmul.s which takes in two matrices, m0 and m1 in row-major format and multiplies them, storing the resulting matrix C in pre-allocated memory. You must use the dot function from the previous task to calculate each entry of the result matrix. Be careful to follow the specification in the header comment in the matmul.s file.

Note: m0 is the left matrix, and m1 is the right matrix.

Hint: The stride for row vectors will be different than the stride for column vectors when calling the dot function. Consider re-reading the section on array strides in the background materials.

Testing: Matrix Multiplication
We only provide a skeleton test for matrix multiplication. By now you should be familiar with how to use the testing framework.

You can run the unit test by running the following command in the unittest directory:

python3 -m unittest unittests.TestMatmul -v


Hint: as before, you will need to add multiple test to achieve 100% coverage.

Submitting Your Code
Please submit using Gradescope to Project 2A, using the GitHub submission option to ensure that your files are in the right place.

Note: you should not add any .import statements to the starter code. For example, when the autograder is importing matmul.s, it will also import dot.s and utils.s, so your matmul.s file itself should never contain any .import statements.

Note: also make sure to not have any ecall instructions in your code. Use the functions we provide in utils.s.

Hint: make sure to consult the general advice and grading section if you want to improve your submission.

Part B: File Operations and Main
Due Monday, October 5th

In this part, you will implement functions to read matrices from and write matrices to binary files. Then you will combine all individual functions to run a pre-trained MNIST digit classifier.

Background Knowledge
Neural Networks
At a basic level, a neural networks tries to approximate a (non-linear) function that maps your input into a desired output. A basic neuron consists of a weighted linear combination of the input, followed by a non-linearity â€“ for example, a threshold. Consider the following neuron, which implements the logical AND operation:



It is easy to see that for , , the linear combination , which is less than the threshold of 1 and will result in a 0 output. With an input , or , the linear combination will results in , which is less than 1 and result in a 0 output. Similarly, , will result in , which is greater than the threshold and will result in a 1 output! What is interesting is that the simple neuron operation can also be described as an inner product between the vector and the weights vector followed by as thresholding, non-linear operation.

More complex functions can not be described by a simple neuron alone. We can extend the system into a network of neurons, in order to approximate the complex functions. For example, the following 2 layer network approximates the logical function XOR:



The above is a 2 layer network. The network takes 2 inputs, computes 2 intemediate values, and finally computes a single final output.

It can be written as matrix multiplications with matrices m_0 and m_1 with thresholding operations in between as shown below:



Convince yourself that this implements an XOR for the appropriate inputs!

You are probably wondering how the weights of the network were determined? This is beyond the scope of this project, and we would encourage you to take advanced classes in numerical linear algebra, signal processing, machine learning and optimization. We will only say that the weights can be trained by giving the network pairs of correct inputs and outputs and changing the weights such that the error between the outputs of the network and the correct outputs is minimized. Learning the weights is called: â€œTrainingâ€. Using the weights on inputs is called â€œInferenceâ€. We will only perform inference, and you will be given weights that were pre-trained by your dedicated TAâ€™s.

Handwritten Digit Classification
In this project we will implement a similar, but slightly more complex network which is able to classify handwritten digits. As inputs, we will use the MNIST data set, which is a dataset of 60,000 28x28 images containing handwritten digits ranging from 0-9. We will treat these images as â€œflattenedâ€ input vectors of size 784 (= 28 * 28). In a similar way to the example before, we will perform matrix multiplications with pre-trained weight matrices m_0 and m_1. Instead of thresholding we will use two different non-linearities: The ReLU and ArgMax functions. Details will be provided in descriptions of the individual tasks.



Matrix File Format
We will use a custom binary format to store the size and integer values of a matrix. We also define a plaintext representation and provide a convert.py script in the tools directory which allows you to translate between the two formats:

python3 convert.py file.bin file.txt --to-ascii to go from binary to plaintext
python3 convert.py file.txt file.bin --to-binary to go from plaintext to binary
Note: the plaintext format is useful for you to get a human readable representation of the matrices while the binary format will be used by your RISC-V assembly code to load and store matrices.

Plaintext Format
The first line of the plaintext file will contain two integers, representing number of rows and columns of the matrix. Every line afterwards is a row of the matrix. For example, a plaintext file containing a 3x3 matrix would look like this:

Note: a newline is required after the last row of the matrix.

Binary Format
The first 8 bytes of the binary file represent two 4 byte integers. These integers are the number of rows and columns of the matrix. Every 4 following bytes represents an integer that is an element of the matrix, in row-major order. There are no gaps between elements. The number of elements must always correspond to the product of number of rows and number of columns. The integers are stores in little-endian format. We elaborate on this bellow.

Note: The size of a MxN matrix stored in this format is sizeof(int) * (2 + m*n).

Viewing Binary Files
In order to view arbitrary binary files on the command line we recommend the xxd command. Its default functionality is to output the raw bits of the file in a hex representation.

For example, letâ€™s say the plaintext example in the previous section is stored in file.txt in the main directory. We can run python convert.py file.txt file.bin --to-binary to convert it to a binary format, then xxd file.bin, which should print the following:

00000000: 0300 0000 0300 0000 0100 0000 0200 0000  ................
00000010: 0300 0000 0400 0000 0500 0000 0600 0000  ................
00000020: 0700 0000 0800 0000 0900 0000            ............


If you interpret this output 4 bytes at a time (equivalent to 8 hex digits) in little-endian order (see below), youâ€™ll see that they correspond to the values in the plaintext file. Donâ€™t forget that the first and second 4 bytes are integers representing the dimensions and the rest are integer elements of the matrix.

Please try out the above example by generating the file.txt, running convert.py and inspecting the result with xxd.

Note: while you can also use the hexdump program to inspect bytes, the ordering/endianness of bytes will be different. In order to keep things simple, xxd will be the only tool supported by TAs in office hours and signoffs.

Note: the simple xxd command also works on the Venus web interface shell.

Endianness
It is important to note that the bytes are in little-endian order. This means the least significant byte is placed at the lowest memory address. For files, the start of the file is considered the â€œlower addressâ€. This relates to how we read files into memory, and the fact that the start/first element of an array is usually at the lowest memory address.

RISC-V uses little-endian by default, and our files are all little-endian as well. In general you should not have to worry about endianness when writing code. But it is important to keep endianess in mind when debugging and inspecting bytes in memory or in a file (e.g., using xxd).

This screenshot from Venus shows how the integer 0x0A0B0C0D is stored in memory:



Ecalls and Utils.s
The ecall instruction is a special command in RISC-V, and corresponds to a environment/system call. We have created helper functions in src/utils.s that wrap around the various different ecalls for you to use. In the project you must never make ecalls directly in you own code. Always use the helper functions.

ecalls are expensive and should be minimally used for efficiency!

All helper functions are documented in inline comments in utils.s, alongside their arguments and return values. Take some time to look through utils.s to familizarize yourself with them. You will need to use them in the following tasks.

File Operations
In this section we are going to provide some more details on the helper functions that are used to access files. You will need to use them in order to implement the read_matrix and write_matrix functions.

fopen
Opens a file that we can then read and/or write to, depending on the permission bit we provide. Returns a file descriptor, which is a unique integer tied to the file Must be called on a file before any other operations can be done on it.

Arguments:
a1 is a pointer to a string containing the filename of the file to open
a2 is an integer denoting the permissions we open the file with. For example, we can open the file with read permissions, which prevents us from writing to it. For this project, we only really care about a few basic permission bits: 0, which corresponds to r for read only permission, and 1 which corresponds to w for write only permission. Note: w will overwrite the file if it already exists, and create it if it doesnâ€™t.
Return Values
a0 is a file descriptor, which is a unique integer tied to the file. We will call future file-related functions on this file descriptor, so we know which opened file weâ€™re reading/writing/closing. On failure, a0 is set to -1.
fread
Reads a given number of bytes from a file into a buffer, which is a preallocated chunk of memory to store the bytes. Note that repeated reads will read consecutive bytes from the file. For example, two freads of 8 bytes on a file will read the first 8 bytes and then the second 8 bytes. It will not read the same 8 bytes twice.

Arguments:
a1 is the file descriptor of the file we want to read from, previously returned by fopen.
a2 is a pointer to the buffer that weâ€™re going to read the bytes from the file into. This must be an appropriate amount of memory that was allocated before calling the function, and passed in as a pointer.
a3 is the number of bytes to read from the file.
Return Values
a0 is the number of bytes actually read from the file. If the number of bytes actually read differs from the number of bytes specified in the input, then we either hit the end of the file or there was an error.
fwrite
Writes a given number of elements of a given size. Like fread, subsequent writes to the same file do not overlap, but are rather appended to each other. Note that unlike fread, we donâ€™t pass in the total number of bytes but rather the total number of elements and the size of each element in bytes. We can multiply the two to find the total number of bytes written.

Additionally, note that our writes arenâ€™t actually saved until we run fclose or fflush.

Arguments:
a1 is the file descriptor of the file we want to write to, previously returned by fopen.
a2 is a pointer to a buffer containing what we want to write to the file.
a3 is the number of elements to write out of the buffer
a4 is the size of each buffer element in bytes
Return Values
a0 is the number of elements actually written to the file. If a0 != a3, then we either hit the end of the file or there was an error.
fclose
Closes the file once weâ€™re done with it, saving any writes weâ€™ve made to it.

Arguments:
a1 is the file descriptor of the file we want to close to, previously returned by fopen.
Return Values
a0 is 0 on success, and -1 otherwise.
Task 1: Read Matrix
Implement the read_matrix function in src/read_matrix.s which uses the file operations we described above to read a binary matrix file into memory. Be careful to follow the specification in the header comment in the read_matrix.s file. Pay special attention to returning the correct exit codes if any file operation fails or doesnâ€™t return the expected number of bytes.

Note: unique exit codes will help you debug your solution by pointing you to where the program exited.

Hint: Recall that the first 8 bytes contains the two 4 byte dimensions of the matrix, which will tell you how many bytes to read from the rest of the file. Additionally, recall that the binary matrix file is already in row-major order.

Hint: Youâ€™ll need to allocate memory for the matrix in this function as well. This will require calls to malloc , which is in util.s and also described in the background section above.

Note: RISC-V only allows for a0 and a1 to be return registers, and our function needs to return three values: The pointer to the matrix in memory, the number of rows, and the number of columns. We get around this by having two int pointers passed in as arguments. We set these integers to the number of rows and columns, and return just the pointer to the matrix.

Testing: Read Matrix
We only provide a skeleton test. By now you should be familiar with how to use the testing framework.

You can run the unit test by running the following command in the unittest directory:

python3 -m unittest unittests.TestReadMatrix -v


Hint: as before, you will need to add multiple test to achieve 100% coverage.

Hint: You can use the fail argument to the execute method in order to make system functions fail. This works for fopen, fclose, fread, fwrite and malloc.

Task 2: Write Matrix
Implement the write_matrix function in src/write_matrix.s which uses the file operations we described above to write from memory to a binary matrix file. Be careful to follow the specification in the header comment in the write_matrix.s file. Pay special attention to returning the correct exit codes if any file operation fails or doesnâ€™t return the expected number of bytes.

Testing: Write Matrix
We only provide a skeleton test. By now you should be familiar with how to use the testing framework.

You can run the unit test by running the following command in the unittest directory:

python3 -m unittest unittests.TestWriteMatrix -v


Hint: as before, you will need to add multiple test to achieve 100% coverage.

Hint: You can use the fail argument to the execute method in order to make system functions fail. This works for fopen, fclose, fread, fwrite and malloc.

Task 3: Putting it all Together
Implement the classify function in src/classify.s. Be careful to follow the specification in the header comment in the classify.s file. Pay special attention to returning the correct exit codes if any file operation fails or doesnâ€™t return the expected number of bytes and the expected printing behavior.

This will bring together everything youâ€™ve written so far, and create a basic sequence of functions that will allow you to classifiy the preprocessed MNIST inputs using the pretrained matrices weâ€™ve provided. You may need to malloc space when reading in matrices and computing the layers of the network, but remember to always free all data allocated at the end of this process. More information about the free function is available in utils.s and the background section above. The classify function will be wrapped by the main.s file meaning you still must follow calling convention! The main.s file, in what we gave you, is a dummy main which will directly call your classify function (and pass in the command line arguments) though it could always do more than that! You should view the classify function as a library function which may be called by a program multiple times to perform classifications on different inputs so you should be very careful to adhear to its specification.

Command Line Arguments and File Paths
The filepaths for the input, m0, m1, and the output to write to will all be passed in on the command line. RISC-V handles command line arguments in the same way as C, at the start of the main function a0 and a1 will be set to argc and argv respectively. In addition, we have added an arg a2 which will tell you if you should print out the classification value and a new line if it is zero. If this is not set to 0, you MUST NOT print out anything or you will fail tests! This arg can be useful if you want to run multiple classifications in the same script.

We will call main.s in the following way from the root directory: java -jar tools/venus.jar <venus flags> src/main.s <M0_PATH> <M1_PATH> <INPUT_PATH> <OUTPUT_PATH>

If youâ€™re testing from any other directory, make sure your path to main.s and filepaths correspond to your CWD (current working directory).

Note that the pointer for to the string M0_PATH will be located at index 1 of argv, M1_PATH at index 2, and so on. venus flags are not considered in total number of command line arguments.

Note: If the number of command line arguments is different from what is expected, exit with the correct exit code.

Note: While classify is its own function, we are acting as if it is the main function. Making it a function other than main is useful as we can now chain classifications and perform more complex procedures as we can get the result of a classification programmatically and perform other operations based off of the result!

The Network
The first thing youâ€™ll need to do (after verifying the number of command line arguments) is load m0, m1, and the input matrices into memory by making multiple calls to read_matrix, using command line arguments. Remember you need to pass in two integer pointers as arguments.

Next, youâ€™ll want to use those three matrices to calculate the scores for our input. Our network consists of a matrix multiplication with m0, followed by a relu on the result, and then a second matrix multiplication with m1. At the end of this, we will have a matrix of scores for each classification. We then pick the index with the highest score, and that index is the classification for our input.

Given two weight matrices m0 and m1, along with an input matrix input, the pseudocode to generate the scores for each class is as follows:

hidden_layer = matmul(m0, input)
relu(hidden_layer) # Recall that relu is performed in-place
scores = matmul(m1, hidden_layer)


Once youâ€™ve obtained the scores, we expect you to save them to the output file passed in on the command line. Then, call argmax, which will return a single integer representing the classification for your input, and print it (if the value of a2 indicates that you should print).

Hint: when calling argmax and relu, you should treat your inputs as 1D arrays. That means the length you pass into the function should be the number of elements in your entire matrix.

Testing classify
A simple sanity check can be run like this:

python3 -m unittest unittests.TestMain -v


You should add more test cases to TestClassify in order to try out some of the corner cases in the spec.

Hint: with the testing facilities that we provide to you, you probably will not be able to reach 100% coverage for your classify code. Do you know why?

Test Inputs and Outputs
All test inputs are contained in inputs. Inside, youâ€™ll find a folder containing inputs for the mnist network, as well three other folders containing smaller networks.

Each network folder contains a bin and txt subfolder. The bin subfolder contains the binary files that youâ€™ll run main.s on, while the txt subfolder contains the plaintext versions for debugging and calculating the expected output.

Within the bin and txt subfolders, youâ€™ll find files for m0 and m1 which define the network, and a folder containing several inputs.

For MNIST, there are two additional folders:

txt/labels/ contains the true labels for each input, which are the actual digits that each corresponding input image contains.
student_inputs/ contains a script to help you run your own input images, as well as an example.
Simple
Apart from MNIST, weâ€™ve provided several smaller input networks for you to run your main function on. simple0, simple1, and simple2 are all smaller inputs that will be easier to debug.

To test on the first input in simple0 for example, run the following:

java -jar tools/venus.jar src/main.s -ms -1 inputs/simple0/bin/m0.bin inputs/simple0/bin/m1.bin inputs/simple0/bin/inputs/input0.bin  outputs/test_basic_main/student_basic_output.bin



You can then convert the written file to plaintext, check that itâ€™s values are correct, and that the printed integer is indeed the index of the largest element in the output file.

python tools/convert.py --to-ascii output.bin output.txt


For verifying that the output file itself is correct, you can run the inputs through a matrix multiplication calculator like this one, which allows you to click â€œinsertâ€ and copy/paste directly from your plaintext matrix file. Make sure you manually set values to zero for the ReLU step.

Note: the provided files cover a variety of dimensions. For example the simple2 inputs have more than one column in them, meaning that your â€œscoresâ€ matrix will also have more than one column. Your code should still work as expected in this case, writing the matrix of â€œscoresâ€ to a file, and printing a single integer that is the row-major index of the largest element of that matrix.

MNIST
All the files for testing the mnist network are contained in inputs/mnist. There are both binary and plaintext versions of m0, m1, and 9 input files.

To test on the first input file for example, run the following:

java -jar venus.jar src/main.s -ms -1 inputs/mnist/bin/m0.bin inputs/mnist/bin/m1.bin inputs/mnist/bin/inputs/mnist_input0.bin  outputs/test_mnist_main/student_mnist_outputs.bin



(Note that we run with the -ms -1 flag, as MNIST inputs are large and we need to increase the max instructions Venus will run)

This should write a binary matrix file student_mnist_outputs.bin which contains your scores for each digit, and print out the digit with the highest score. You can compare the printed digit versus the one in inputs/mnist/txt/labels/label0.txt.

You can check the printed digit printed by main against the plaintext labels for each of the input files in the mnist/txt/labels folder.

Weâ€™ve also included a script inputs/mnist/txt/print_mnist.py, which will allow you to view the actual image for every mnist input. For example, you can run the following command from the directory inputs/mnist/txt to print the actual image for mnist_input8 as ASCII art alongside the true label. If you run the command from your root directory, include the full path.

Hint: not all inputs will classify properly. A neural network will practically never have 100% accuracy in its predictions. In our test cases specifically, mnist_input2 and mnist_input7 will be misclassified to 9 and 8 respectively. All other test cases should classify correctly.

Generating Your Own MNIST Inputs
Just for fun, you can also draw your own handwritten digits and pass them to the neural net. First, open up any basic drawing program like Microsoft Paint. Next, resize the image to 28x28 pixels, draw your digit, and save it as a .bmp file in the directory inputs/mnist/student_inputs/.

Inside that directory, weâ€™ve provided bmp_to_bin.py to turn this .bmp file into a .bin file for the neural net, as well as an example.bmp file. To convert it, run the following from inside the inputs/mnist/student_inputs directory:

python bmp_to_bin.py example


This will read in the example.bmp file, and create an example.bin file. We can then input it into our neural net, alongside the provided m0 and m1 matrices.

java -jar venus.jar src/main.s -ms -1 -it inputs/mnist/bin/m0.bin inputs/mnist/bin/m1.bin inputs/mnist/student_inputs/example.bin  outputs/test_mnist_main/student_input_mnist_output.bin



You can convert and run your own .bmp files in the same way. You should be able to achieve a reasonable accuracy with your own input images.

Submitting Your Code
Please submit using Gradescope to Project 1B, using the GitHub submission option to ensure that your files are in the right place.

Note: you should not add any .import statements to the starter code. For example, when the autograder is importing matmul.s, it will also import dot.s and utils.s, so your matmul.s file itself should never contain any .import statements.

Note: also make sure to not have any ecall instructions in your code. Use the functions we provide in utils.s.

Hint: make sure to consult the general advice and grading section if you want to improve your submission.

Frequently Asked Questions
General
Q G.1: Which lectures are required for working on project 2?
A G.1: lectures 7, 8, 9 and 10
Q G.2: Are there preformance requirements? A G.2: While there are no specific requirements, your program must be reasonably efficient. Each test of the autograder gives a timeout much larger than what it takes for the staff solution to run so if your submission times out, your solutions is not efficient. Common causes is excessive calls to ecalls. Those should be used spareingly otherwise your program will become much less efficient.
Q G.3: If I have a bug in , will I lose credit for other functions which use this function? **A G.3**: No! We have designed the autograder to only test a specific function at a time. This means if you fail a test, it will not cause you to fail other tests. Note that if there are multiple tests testing the same function for different things, you will fail those tests.
Unit Testing Framework
Q U.1: Why am I not able to git add the generated tests in unittests/assembly?
A U.1: We added a .gitignore file in unittests, because committing generated files is generally considered bad practise.
Q U.2: Why do I get an unrecognized arguments -k [...] error when trying to run the unittests?
A U.2: The -k flag was only added in Python 3.7. The project spec was updated with commands that should work on older Python versions as well.
Q U.3: How can we check the return code?
A U.3: You can change the optional code argument to the execute method of the AssemblyTest class. By default the expected code is 0, to check a different exit code follow the usage t.execute(code=78).
Q U.4: Can we import non-standard libraries like numpy?
A U.4: The autograder will only have access to the Python standard library and an import numpy will make it fail. You can always play around with numpy by making a new unittest file. However, these additional tests will not be considered by the autograder.
Q U.5: What exactly do you measure for coverage?
A U.5: We measure the number of times an instruction in your implementation (e.g. in abs.s) was executed across all your tests. So a single test alone does not need to cover all instructions in your code. In order to get points for coverage you need to have tests that - together - execute every single instruction in your implementation at least once. Simply, cover all branches and different flows of execution through your program.
Q U.6: How can I see the instructions that I am not covering?
A U.6: In the call to print_coverage, that will be executed after all your tests are run, change verbose to True. This will print out the coverage for every single instruction in your implementation.
Q U.7: Why am I getting an argument of type 'WindowsPath' is not iterable error on Windows?
A U.7: On Windows you need Python 3.8 (the latest stable release) to run the unit tests. Alternatively you can use WSL which should work with older Python 3 versions.
Q U.8: Can we change the arguments to some of the tests?
A U.8: Feel free to change the code we provide. The only thing that needs to stay the same are the names of the TestCase classes. The autograder has these hard coded when measuring your coverage.
Q U.9: Why am I getting a ImportError: Failed to import test module: TestAbs error?
A U.9: You need to run the unit tests from the unittests directory!
Part A
Abs
Q A.1: How thoroughly should we test the abs function?
A A.1: The abs function is just an introductory example. If you did everything we showed you in the intro video, you should be good to go!
Q A.2: Are we graded on abs?
A A.2: The autograder checks to make sure that you successfully made the changes that we show you in the video. Nothing beyond that.
ReLU and ArgMax
Q X.1: How do I exit (or terminate) the program with an error code?
A X.1: Have a look at the exit2 function that we provide in utils.s
Q X.2: Should we copy over functions from utils.s to our own code?
A X.2: Please never copy a function out of utils.s! When you write a unit test, utils.s will automatically be imported. When debugging in venus, make sure that you run your unit test (found in unittests/assembly) instead of trying to run the relu.s file directly, e.g., vdb unittests/assembly/TestRelu_test_simple.s. We show you how to do this in the introductory video.
Q X.3: Why do I get a could not find label exit2 or label exit2 used but not defined error?
A X.3: You should never run your relu.s file in venus. Instead run a unit test, e.g., vdb unittests/assembly/TestRelu_test_simple.s
Q X.4: What do you mean by a 1-D vector?
A X.4: The relu function will treat the matrix as a contiguous vector, e.g. a 3x2 matrix would be treated as a vector of size 6.
Q X.5: Do we always need to fill in an epilogue and a prologue?
A X.5: You always need to obey by the calling convention! Sometimes no additional code is required for that and the epilogue or the prologue may be left empty in that case.
Dot Product
Q D.1: How can I verify that the vector length argument actually matches the size of the memory allocated for the vector? OR How can I verify that enough memory was allocated for the vector?
A D.1: Like in C, there is no way for the function to verify that the vector length argument actually matches the size of memory allocated for the vector.
Q D.2: Are we allowed to add extra labels?
A D.2: Yes, just do not make them global (.globl).
Q D.3: Can we assume that the autograder might change registers to test calling convention like lab04â€™s autograder did?
A D.3: The autograder might change some registers when you call a function (but only the ones it is allowed to overwrite). Make sure to follow the calling conventions, also when calling your own functions (like dot from matmul)!
Matmul
Q M.1: Can we assume that the memory region pointed to by a6 has enough space to store the result?
A M.2: The region of memory that a6 is pointing to has enough space to fit all values of the result d. The matmul function itself does not have to call malloc to allocate space for the result.
Q M.3: Can we assume that the dimensions that are provided in the argument match the number of elements in the array? If we cannot, how can we check the length of the array?
A M.3: Like in C, there is no way for the function to verify that the matrix size argument actually matches the size of memory allocated for the matrix.
Q M.4: Is matmul only supposed to work on matrices that are square?
A M.4: Matrices donâ€™t need to be square. Checking that the dimensions of m0 and m1 match is one of the three error checks you need to perform (see the description in matmul.s for a list of all the checks you need to perform).
Q M.5: Can we assume that d is initialized to anything in particular?
A M.5: No. Assume that enough memory for d is allocated, but the values are uninitialized.
Q M.6: Is it ok to check for invalid arguments before the Prologue?
A M.6: Yes. Just make sure that you do not violate the calling conventions.
Q M.7: Is it ok to save the value of a t register to the stack and restore it after calling a function?
A M.7: Yes. All the calling convention says is that t registers could contain arbitrary values after you call a function. Just make sure to properly decrement/increment the stack pointer.
Q M.8: What does it mean for the dimensions of m0 and m1 to â€œmake senseâ€?
A M.8: The number of rows and columns should be greater or equal to 1.
Q M.9: If both the dimensions of m0 and the dimensions of m1 donâ€™t make sense, should we exit with code 72 or 73?
A M.9: You need to check the errors from top to bottom in the order they are listed in the header comment.
Part B
Read Matrix
Q R.1: How can we tell if malloc failed?
A R.1: The returned address will be 0.
Q R.2: How can we tell if fopen failed?
A R.2: Please read the section on fopen in the project spec.
Q R.3: When are we supposed to exit with code 1?
A R.3: Please never exit with code 1. We had some old instructions that we failed to remove (fixed now). This semester, all error codes are two digit numbers (decimal).
Q R.4: Some of my .data is not aligned to a multiple of four. Why?
A R.4: The venus linker does not align any of the static data sections. Thus a .word could start at any address.
Q R.5: What error code should we use if the matrix is empty?
A R.5: Since we do not specify an error code for this, you can assume that all matrices that are read in will have dimensions that make sense.
Q R.6: How can we test that the output array of read_matrix is correct?
A R.6: Checkout the check_array_pointer method of the AssemblyTest class.
Write Matrix
Q W.1: Are we supposed to call fflush?
A W.1: There should be no need to call fflush.
Q W.2: What exit code should I return if malloc fails?
A W.2: While using malloc is not required to implement this function, you should always return the exit code 88 in case malloc fails.
Q W.3: do_write_matrix always checks the output file, but when I am testing an error case, there will be no file produced. How can I deal with this?
A W.3: You are free to add your own code to do_write_matrix, e.g., in order to skip the file check when it is unnecessary
Classify
Q C.1: Can we assume that the input matrix is flattened?
A C.1: The inputs to the MNIST and the simple0 networks will be matrices with N rows and a single column. You can look at example inputs like this: cat inputs/simple0/txt/inputs/input0.txt. However, the simple2 network actually expects inputs with more than one column. Please consult the project spec to try and understand how to handle that case.
Q C.2: How long should it take to classify an MNIST input?
A C.2: On a 5-year old laptop with OpenJDK 1.8, the staff solution takes ~33s or ~1.2 million instructions to classify mnist_input0.bin.
Q C.3: Do we have to free previously allocated memory if a call to malloc fails?
A C.3: No. You do not need to free before exiting.
Q C.4: What is the difference between TestClassify and TestMain?
A C.4: TestMain is very similar to the sanity checks that the autograder runs. TestClassify was meant for you to extend in order to test corner cases. For example TestMain always sets a0 to 0, TestClassify should test the other value for a2.
Q C.5: How long does the autograder take? A C.5: On average it can take 2-5min to run.
Q C.6: Should our code be able to create a folder if a directory in the output path does not exist?
A C.6: No. You can assume that the output directory exists. Only the file needs to be created by fopen.
Previous
Project1
Next
Project3
Background  èƒŒæ™¯
Objectives  ç›®æ ‡
Getting Started  å…¥é—¨æŒ‡å—
Java and Python 3 Setup  
Part A: Mathematical Functions  
General Advice and Grading  
Task 0: Getting Started with the Abs Function  
Background Knowledge  
Task 1: ReLU  
Task 2: ArgMax  
Task 3.1: Dot Product  
Task 3.2: Matrix Multiplication  
Submitting Your Code  æäº¤æ‚¨çš„ä»£ç 
Part B: File Operations and Main  
Background Knowledge  
Neural Networks  
Handwritten Digit Classification  
Task 1: Read Matrix  
Task 2: Write Matrix  
Task 3: Putting it all Together  
Submitting Your Code  æäº¤æ‚¨çš„ä»£ç 
Frequently Asked Questions  
General  
Unit Testing Framework  
Part A  
Part B  éƒ¨åˆ† B

CSå­¦ä¹ ç¤¾åŒº
è·¯çº¿å›¾
ç¤¾åŒº
Discord
æèµ 
æèµ æˆ‘ä»¬
Copyleft Â© 2025 My Project, Inc. Built with Docusaurus.
Skip to main content
è·³è½¬åˆ°ä¸»è¦å†…å®¹
ğŸ‰ï¸ğŸ‰ï¸ğŸ‰ï¸è¯¾ç¨‹æ–‡æ¡£æ±‰åŒ–å·¥ä½œæ­£åœ¨è¿›è¡Œä¸­ ğŸ‰ï¸ğŸ‰ï¸ å­¦ä¹ äº¤æµç¾¤è¯·åˆ° ç¤¾åŒºé¡µé¢ æŸ¥çœ‹å…¥ç¾¤æ–¹å¼ ğŸ‰ï¸ğŸ‰ï¸ğŸ‰ï¸
TeachYourselfCS
TeachYourselfCS
è·¯çº¿å›¾
è¯¾ç¨‹èµ„æº
åšå®¢
ç¤¾åŒº
æèµ æˆ‘ä»¬

å‰è¨€
è·¯çº¿å›¾
è¯¾ç¨‹èµ„æº

cs50x

cs61a

cs61b

cs61c

syllabus-è¯¾ç¨‹å¤§çº²
labs
projects
  é¡¹ç›®
Project1
  é¡¹ç›® 1
Project2
  é¡¹ç›® 2
Project3
  é¡¹ç›® 3
Project4
  é¡¹ç›® 4
MIT 18.01

MIT 18.02

MIT 18.06

MIT 6.042J

cs162

cs144

CMU 15-445

py4e

è¯¾ç¨‹èµ„æºcs61cprojectsProject3
Project 3: CS61CPU    
Overview  
Part A Deadline: Friday, October 16, 2020  

Part B Deadline: Sunday, November 1, 2020  

So youâ€™ve (hopefully) dealt with CS61Classify. But, you might be wondering, how exactly do all those sw ra, 40(sp) instructions get executed? Whatâ€™s inside that mystery chip in your computer called the â€œCPUâ€? Welcome to Project 3!  

In Part A (Tasks 1-3), youâ€™ll be wiring up the ALU and RegFile for a basic RISC-V CPU, as well as implementing the CPU datapath for executing addi instructions. In Part B (Tasks 4-5), youâ€™ll use these components (and others) to wire up a working CPU that runs actual RISC-V instructions!  

Tips and Guidelines  
Do not use the version of Logisim preinstalled on the Soda lab computers, as this will mess up your circuits! Use the logisim-evolution.jar provided in your project repository.  
You are only allowed to use Logisimâ€™s built-in blocks from the following libraries for all parts of this project: Wiring (except Transistor, Transmission Gate, POR, Pull Resistor, Power, Ground, POR, Do not connect), Gates, Plexers, Arithmetic (except Divider), Memory (except RAM, Random Generator) Note that the use of ROM is allowed.  
Save frequently and commit frequently! Try to save your code in Logisim every 5 minutes or so, and commit every time you produce a new feature, even if it is small.  
Sanity tests for most project tasks are included with the project starter code. More information is available under the Testing section of each task.  
See this video for a custom tests and debugging walkthrough video  
Do not move the input and output pins in your circuit, since this could knock the pins out of alignment (in other words, autograder tests will fail)! Check the harness circuits, as well as cpu.circ, to make sure your circuits fit in the testing harnesses.  
You may make new subcircuits, but they must be located in the files given in the starter code. You may not make new .circ files; the autograder will fail you if you do this!  
You must use unique names for each subcircuit across all .circ files. Failing to do this will result in reduced autograder points. You may not change the names of any circuits provided in the starter files.  
.circ files use the XML format, which makes it hard for Git to automerge. We recommend working on a single computer at a time; if you use multiple computers, make sure that you have pushed and pulled your code before switching devices.  
Your submission must be reasonably efficient: It should not take a very long time to run a single test.  
We recommend completing Lab 05 before starting on Part A of the project and Lab 06 before starting on Part B of this project. Both labs cover many Logisim basics that will be useful for the respective parts of the project.  
A Logisim library reference can be found by going to Help->Library Reference within Logisim.  
Some common sources of Logisim errors, for your debugging convenience:  
alt-text
Part A: Getting Started    
For this project, the computer youâ€™re working on needs be able to run Java and Python 3, which you should have set up in Project 2. This project specification will use python3 for sample commands; depending on your system, you may need to use python or py instead. We will be using Logisim Evolution, a Java-based GUI program, so we strongly recommend working on a laptop or desktop with Java installed and a monitor directly attached. Using window forwarding over a Hive SSH session is discouraged, and may lead to instability and general headaches.    

Please follow the directions in this Google Form to get a repository: https://docs.google.com/forms/d/e/1FAIpQLSf6m3CjVF1IxwM6l1dTRjeAtTqwk_5974pOFvhdwCr0ZYrqDQ/viewform?usp=sf_link. After completing the form, clone your GitHub Classroom repository and add the starter code repository as a remote:    

$ git clone YOUR_REPO_URL
$ cd YOUR_REPO_NAME
$ git remote add starter https://github.com/61c-teach/fa20-proj3-starter.git
$ git pull starter master


If we make changes to the starter code, you can update your repository with git pull starter master.    

Task 1: Arithmetic Logic Unit (ALU)    
Your first task is to create an ALU that supports all the operations needed by the instructions in our ISA (which is described in further detail in the next section). Please note that we treat overflow as RISC-V does with unsigned instructions, meaning that we ignore overflow.    

We have provided a skeleton of an ALU for you in alu.circ. It has three inputs:    

Input Name    	Bit Width    	Description  æè¿°
A	32	Data to use for Input A in the ALU operation    
B	32	Data to use for Input B in the ALU operation    
ALUSel    	4	Selects which operation the ALU should perform (see the list of operations with corresponding switch values below)    
â€¦ and one output:    

Output Name    	Bit Width    	Description  æè¿°
Result    	32	Result of the ALU operation    
Below is the list of ALU operations for you to implement, along with their associated ALUSel values. All of them are required. You are allowed and encouraged to use built-in Logisim blocks to implement the arithmetic operations. Please note that mulh is no longer extra credit due to the addition of a signed multiplier in Logisim which makes implementation as simple as mulhu.

Switch Value	Instruction
0	add: Result = A + B
1	and: Result = A & B
2	or: `Result = A
3	xor: Result = A ^ B
4	srl: Result = (unsigned) A >> B
5	sra: Result = (signed) A >> B
6	sll: Result = A << B
7	slt: Result = (A < B (signed)) ? 1 : 0
8	Unused
9	Unused
10	mul: Result = (signed) (A * B)[31:0]
11	mulhu: Result = (A * B)[63:32]
12	sub: Result = A - B
13	bsel: Result = B
14	mulh: Result = (signed) (A * B)[63:32]
When implementing mul and mulh, notice that the multiply block has a â€œCarry Outâ€ output (the adder block also has this, but you will not need this).

You can make any modifications to alu.circ you want, but the outputs must obey the behavior specified above. If you create additional subcircuits, they must also be in alu.circ (you may not make new .circ files). Additionally, your ALU must be able to fit in the provided harness alu_harness.circ. This means that you should take care not to move inputs or outputs. To verify that changes you made didnâ€™t break anything, you can open alu_harness.circ and ensure there are no errors and that the circuit functions well.

Hints:

add is already made for you; feel free to use a similar structure when implementing your other blocks.
You can hover your cursor over an input/output on a block to get more detailed information about that input/output.
If you want to know more details about each block, go to Help->Library Reference for more information on the block and its inputs and outputs.
You might find bit splitters or extenders useful when implementing sra and srl.
Use tunnels! They will make your wiring cleaner and easier to follow, and will reduce your chances of encountering crossed wires or unexpected errors.
A multiplexer (MUX) might be useful when deciding which block output you want to output. In other words, consider simply processing the input in all blocks, and then outputing the one of your choice.
ALU Testing
Weâ€™ve provided a group of ALU sanity tests in the tests/part_a/alu directory. Running the test runner for this group will run the ALU tests and produce output in the tests/part_a/alu/student_output directory. As a reminder you can find a debugging walkthrough at this video.

$ python3 test_runner.py part_a alu


Weâ€™ve also provided binary_to_hex_alu.py, which can interpret this output in a readable format for you. To use it, do the following:

$ cd tests/part_a/alu
$ python3 binary_to_hex_alu.py PATH_TO_OUTPUT_FILE


For example, to see reference_output/alu-add-ref.out in readable format, you would do this:

$ cd tests/part_a/alu
$ python3 binary_to_hex_alu.py reference_output/alu-add-ref.out


If you want to see the difference between your output and the reference solution, put the readable outputs into new .out files and diff them. For example, for the alu-add test, you would do:

$ cd tests/part_a/alu
$ python3 binary_to_hex_alu.py reference_output/alu-add-ref.out > reference.out
$ python3 binary_to_hex_alu.py student_output/alu-add-student.out > student.out
$ diff reference.out student.out


Task 2: Register File (RegFile)
As you learned in class, RISC-V architecture has 32 registers. For this project we will implement all of them. To aid in debugging we have written the regfile to expose the 9 ports specified below. Please make sure that the values of these register are attached to the proper outputs.

Your RegFile should be able to write to or read from these registers specified in a given RISC-V instruction without affecting any other registers. There is one notable exception: your RegFile should NOT write to x0, even if an instruction tries. Remember that the zero register should ALWAYS have the value 0x0. You should NOT gate the clock at any point in your RegFile: the clock signal should ALWAYS connect directly to the clock input of the registers without passing through ANY combinational logic.

The exposed registers and their corresponding numbers are listed below.

Register Number	Register Name
x0	x0
x1	ra
x2	sp
x5	t0
x6	t1
x7	t2
x8	s0
x9	s1
x10	a0
You are provided with the skeleton of a register file in regfile.circ. The register file circuit has six inputs:

Input Name	Bit Width	Description
Clock	1	Input providing the clock. This signal can be sent into subcircuits or attached directly to the clock inputs of memory units in Logisim, but should not otherwise be gated (i.e., do not invert it, do not â€œandâ€ it with anything, etc.).
RegWEn	1	Determines whether data is written to the register file on the next rising edge of the clock.
Read Register 1 (rs1)	5	Determines which registerâ€™s value is sent to the Read Data 1 output, see below.
Read Register 2 (rs2)	5	Determines which registerâ€™s value is sent to the Read Data 2 output, see below.
Write Register (rd)	5	Determines which register to set to the value of Write Data on the next rising edge of the clock, assuming that RegWEn is a 1.
Write Data (wb)	32	Determines what data to write to the register identified by the Write Register input on the next rising edge of the clock, assuming that RegWEn is 1.
The register file also has the following outputs:

Output Name	Bit Width	Description
rs1	32	Driven with the value of the register identified by the Read Register 1 input.
rs2	32	Driven with the value of the register identified by the Read Register 2 input.
ra Value	32	Always driven with the value of ra (This is a DEBUG/TEST output.)
sp Value	32	Always driven with the value of sp (This is a DEBUG/TEST output.)
t0 Value	32	Always driven with the value of t0 (This is a DEBUG/TEST output.)
t1 Value	32	Always driven with the value of t1 (This is a DEBUG/TEST output.)
t2 Value	32	Always driven with the value of t2 (This is a DEBUG/TEST output.)
s0 Value	32	Always driven with the value of s0 (This is a DEBUG/TEST output.)
s1 Value	32	Always driven with the value of s1 (This is a DEBUG/TEST output.)
a0 Value	32	Always driven with the value of a0 (This is a DEBUG/TEST output.)
The test outputs at the top of your regfile.circ file are present for testing and debugging purposes. If you were implementing a real register file, you would omit those outputs. In our case, be sure they are included correctlyâ€“if they are not, you will not pass.

You can make any modifications to regfile.circ you want, but the outputs must obey the behavior specified above. If you create additional subcircuits, they must also be in regfile.circ (you may not make new .circ files). In addition, your regfile.circ that you submit must fit into the regfile_harness.circ file we have provided for you. This means that you should take care not to move inputs or outputs. To verify changes you have made didnâ€™t break anything, you can open regfile_harness.circ and ensure there are no errors and that the circuit functions well.

Hints:

Take advantage of copy-paste! It might be a good idea to make one register completely and use it as a template for the others to avoid repetitive work.
I would advise you not to use the enable input on your MUXes. In fact, you can turn that feature off. I would also advise you to also turn â€œthree-state?â€ to off. Take a look at all the inputs to a Logisim register and see what they all do.
Again, MUXes are your friend, but also DeMUXes.
Think about what happens in the register file after a single instruction is executed. Which values change? Which values stay the same? Registers are clock-triggeredâ€“what does that mean?
Keep in mind registers have an â€œenableâ€ input available, as well as a clock input.
What is the value of x0?
RegFile Testing
Weâ€™ve provided a group of RegFile sanity tests in the tests/part_a/regfile directory. Running the test runner for this group will run the ALU tests and produce output in the tests/part_a/regfile/student_output directory.

$ python3 test_runner.py part_a regfile


Weâ€™ve also provided binary_to_hex_regfile.py, which works like binary_to_hex_alu.py from Task 1.

Task 3: The addi Instruction
As your final task for Part A, youâ€™re going to implement a CPU thatâ€™s capable of executing one instruction: addi! Youâ€™re welcome to implement other instructions at this time, but youâ€™ll only be graded on whether or not addi executes correctly for Part A. In Part B, there will be more detailed instructions on how to implement the other instructions.

Info: Memory
The Memory unit (located in mem.circ) is already fully implemented for you and attached to the outputs of your CPU in test_harness.circ! The addi instruction does NOT use the Memory unit, so you leave those ouputs undriven for Part A. Note that the supplied memory is word-addressable but byte level write enabled. This means that the Write_En signal is 4 bits wide and acts as a write mask for the input data. For example, if Write_En is 1'b1000, only the most significant byte of the addressed word in memory will be overwritten. The ReadData port will always return the value in memory at the supplied address, regardless of Write_En.

Hereâ€™s a quick summary of its inputs and outputs:

Signal Name	Direction	Bit Width	Description
WriteAddr	Input	32	Address to read/write to in Memory
WriteData	Input	32	Value to be written to Memory
Write_En	Input	4	The write mask for instructions that write to Memory and zero otherwise
CLK	Input	1	Driven by the clock input to the CPU
ReadData	Output	32	Value of the data stored at the specified address
Info: Branch Comparator
The Branch Comparator unit (located in branch_comp.circ) provided in the skeleton is unimplemented, but the addi instruction does NOT use the Branch Comparator unit, so you donâ€™t have to worry about it for Part A.

If you are interested, hereâ€™s a quick summary of its inputs and outputs:

Signal Name	Direction	Bit Width	Description
rs1	Input	32	Value in the first register to be compared
rs2	Input	32	Value in the second register to be compared
BrUn	Input	1	Equal to one when an unsigned comparison is wanted, or zero when a signed comparison is wanted
BrEq	Output	1	Equal to one if the two values are equal
BrLt	Output	1	Equal to one if the value in rs1 is less than the value in rs2
Info: Immediate Generator
The Immediate Generator (â€œImm Genâ€) unit (located in imm_gen.circ) provided in the skeleton is unimplemented. The addi instruction requires an immediate generator, but for now you can hard-wire it to construct the immediate for the addi instruction, without worrying about other immediate types.

To edit this subcircuit, edit the imm_gen.circ file and not the imm_gen in cpu.circ. Note that if you modify this circuit, you will need to close and open cpu.circ to load the changes in your CPU.

Hereâ€™s a quick summary of its inputs and outputs:

Signal Name	Direction	Bit Width	Description
inst	Input	32	The instruction being executed
ImmSel	Input	3	Value determining how to reconstruct the immediate
imm	Output	32	Value of the immediate in the instruction
Info: Processor
We have provided a skeleton for your processor in cpu.circ. You will be using your own implementations of the ALU and RegFile as you construct your datapath. You are responsible for constructing the entire datapath from scratch. For Part A, your completed processor should support the addi instruction using a two-stage pipeline, with IF in the first stage and ID, EX, MEM, and WB in the second stage. To start, however, we recommend you create a single-stage processor with no pipelining. Once that is working, you can modify your processor so that it has a 2-stage pipeline.

Your processor will sit in a processor harness test_harness.circ that contains the Memory unit. That processor harness then sits in a testing harness run.circ that provides the instructions to the processor. Your process will output the address of an instruction, and accept the instruction at that address as an input. It will also output the data memory address, data memory write enable, and accept the data at that address as an input. Essentially, these two test harnesses are your data memory and instruction respectively. We recommend that you take some time to inspect test_harness.circ and run.circ to see exactly whatâ€™s going on. test_harness.circ will be used in the tests provided to you for sanity checking, so make sure your CPU fits in the harness before testing and submitting your work! Your processor has 3 inputs that come from the harness:

Input Name	Bit Width	Description
READ_DATA	32	Driven with the data at the data memory address identified by the WRITE_ADDRESS (see below).
INSTRUCTION	32	Driven with the instruction at the instruction memory address identified by the FETCH_ADDRESS (see below).
CLOCK	1	The input for the clock. As with the register file, this can be sent into subcircuits (e.g. the CLK input for your register file) or attached directly to the clock inputs of memory units in Logisim, but should not otherwise be gated (i.e., do not invert it, do not AND it with anything, etc.).
Your processor must provide the following outputs to the first level harness:

Output Name	Bit Width	Description
ra	32	Driven with the contents of ra (FOR TESTING)
sp	32	Driven with the contents of sp (FOR TESTING)
t0	32	Driven with the contents of t0 (FOR TESTING)
t1	32	Driven with the contents of t1 (FOR TESTING)
t2	32	Driven with the contents of t2 (FOR TESTING)
s0	32	Driven with the contents of s0 (FOR TESTING)
s1	32	Driven with the contents of s1 (FOR TESTING)
a0	32	Driven with the contents of a0 (FOR TESTING)
tohost	32	Driven with the contents of CSR 0x51E (FOR TESTING)
WRITE_ADDRESS	32	This output is used to select which address to read/write data from in data memory.
WRITE_DATA	32	This output is used to provide write data to data memory.
WRITE_ENABLE	4	This output is used to provide the write enable mask to data memory.
fetch_addr	32	This output is used to select which instruction is presented to the processor on the INSTRUCTION input.
Just like with the ALU and RegFile, be careful NOT to move the input or output pins! See the â€œTestingâ€ section for more information on the harness and tests.

Info: Control Logic
The Control Logic unit (control_logic.circ) provided in the skeleton is unimplemented. Designing your control logic unit will probably be your biggest challenge in Part B. For Part A, you can put a constant for each control signal, because addi is the only instruction youâ€™ll be implementing. As you implement addi, think about where youâ€™ll need to make additions in order to support other instructions.

To edit this subcircuit, edit the control_logic.circ file and not the control_logic in cpu.circ. Note that if you modify this circuit, you will need to close and open cpu.circ to load the changes in your CPU.

You are welcome to add more inputs or outputs to the existing starter circuit as your control logic demands. You may also use as many or as few of the supplied ports as needed. That being said, please do not change or remove any of the existing ports during this process.

Single Stage CPU: A Guide
We know that trying to build a CPU with a blank slate might be intimidating, so we wrote the following guide to help you.

Recall the five stages of the CPU pipeline:

Instruction Fetch (IF)
Instruction Decode (ID)
Execute (EX)
Memory (MEM)
Write Back (WB)
This guide will help you work through each of these stages for the addi instruction. Each section will contain questions for you to think through and pointers to important details, but it wonâ€™t tell you exactly how to implement the instruction.

You may need to read and understand each question before going to the next one, and you can see the answers by clicking on the question. During your implementation, feel free to place things in subcircuits as you see fit.

Stage 1: Instruction Fetch
The main thing we are concerned about in this stage is: how do we get the current instruction? From lecture, we know that instructions are stored in the instruction memory, and each of these instructions can be accessed through an address.

1. Which file in the project holds your instruction memory? How does it connect to your `cpu.circ` file? The instruction memory is the ROM module in `run.circ`. It provides an input into your CPU named `INSTRUCTION` and takes an output from your CPU. In your `cpu.circ` file, that output is called `PROGRAM_COUNTER`. In `run.circ`, it is called `fetch_addr`. 2. In your CPU, how would changing the address you output as `PROGRAM_COUNTER` affect the instruction input? The instruction that `run.circ` outputs to your CPU should be the instruction at address `PROGRAM_COUNTER` (or `fetch_addr`) in instruction memory. 3. How do you know what `PROGRAM_COUNTER` should be? `PROGRAM_COUNTER` is the address of the current instruction being executed, so it is saved in the PC register. For this project, your PC will start at 0, as that is the default value for a register. 4. For basic programs without any jumps or branches, how will the PC change from line to line? The PC must increment by 1 instruction in order to go to the next instruction, as the address held by the PC register represents what instruction to execute. This means that your PC will typically increase by 4 (assuming no branch or jump) line to line.

In cpu.circ, we have provided a simple PC register implementation - ignoring jumps and branches. You will implement branches and jumps in Part B of the project, but for now we are only concerned with being able to run addi instructions.

Remember that we will eventually implement a 2-stage pipelined processor, so the IF stage is separate from the remaining stages. What circuitry separates the different stages of a pipeline? Specifically, what circuitry separates IF from the next stage? Will you need to add anything?

Stage 2: Instruction Decode
Now that we have our instruction coming from the instruction input, we break it down in the Instruction Decode step according to the RISC-V instruction formats you have learned.

1. What type of instruction is addi? What are the different bit fields and which bits are needed for each? I type. The fields are: - `imm [31-20]` - `rs1 [19-15]` - `funct3 [14-12]` - `rd [11-7]` - `opcode [6-0]` 2. In Logisim, what tool would you use to split out different groups of bits? The Splitter!

3. Implement the instruction field decode stage using the instruction input. You should use tunnels to label and group the bits.

4. Now we need to get the data from the corresponding registers, using the register file. Which instruction fields should be connected to the register file? Which inputs of the register file should it connect to? Instruction field `rs1` will need to connect to read register 1.

5. Implement reading from the register file. You will have to bring in your RegFile from Part A. Remember to connect the clock!

6. What does the Immediate Generator need to do? For addi, the immediate generator takes in 12 bits from the instruction and produces a signed 32-bit immediate. You will need to implement this logic in the Immediate Generator subcircuit!

Stage 3: Execute
The Execute stage is where the computation of most instructions is performed. This is also where we will introduce the idea of using a Control Module.

1. For the add instruction, what should be your inputs to the ALU? Read Data 1 (rs1) and the immediate produced by the Immediate Generator. 2. In the ALU, what is the purpose of ALU_Sel? It determines which operation the ALU will perform. 3. Although it is possible for now to just put a constant as the ALUSel, why would this be infeasible as you implement more instructions? With more instructions, the input to the ALU might need to change, so you will need to have some sort of circuit that changes ALUSel depending on the instruction being executed.

4. Bring in your ALU and connect the ALU inputs correctly. Do you need to connect the clock? Why or why not?

Stage 4: Memory
The memory stage is where the memory can be written to using store instructions and read from using load instructions. Because the addi instruction does not use memory, we will not spend too much time here.

At this point, we cannot connect most of the inputs, as we donâ€™t know where they should come from.

Stage 5: Write Back
The write back stage is where the results of the operation is saved back to the registers.

1. Do `addi` instructions need to write back to a register? Yes. `addi` takes the output of a an addition computation in the ALU and writes it back to the register file.

2. Let's create the write back phase so that it is able to write both ALU and MEM outputs to the Register File. Later, when you implement branching/jumping, you may need to add more to this mux. However, at the moment, we need to choose between the ALU and MEM outputs, as only one wire can end up being an input to the register file. Bring a wire from both the ALU and `READ_DATA`, and connect it to a MUX.

3. What should you use as the Select input to the MUX? What does the input depend on? This input should be able to choose between three MUX inputs: (1) ALU, (2) MEM [`READ_DATA`], and (3) PC + 4 (when will you use this?) The control signal that determines which of these inputs is written back is called WBSel. For now, there should only be one value that WBSel can take on -- whatever it should be for `addi`. 4. Now that we have the inputs to the MUX sorted out, we need to wire the output. Where should the output connect to? Because the output is the data that you want to write into the Register File, it should connect to the Write Data input on the Register File.

5. There are two more inputs on the Register File which are important for writing data: RegWEn and rd. One of these will come from the Instruction Decode stage and the other one will be a new control signal that you need to design for Part B. Please finish off the Writeback stage by these inputs on the RegFile correctly.

If you have done all of the steps correctly, you should have a single-cycle processor that works for addi instructions.

Run python3 test_runner.py part_a addi_single and see if itâ€™s working correctly!

Pipelining Your CPU
Now itâ€™s time to implement pipelining in your CPU! For this project, youâ€™ll need to implement a 2-stage pipeline, which is still conceptually similar to the 5-stage pipeline covered in lecture and discussion (review those if you havenâ€™t already). The two stages youâ€™ll implement are:

1. Instruction Fetch: An instruction is fetched from the instruction memory.

2. Execute: The instruction is decoded, executed, and committed (written back). This is a combination of the remaining four stages of a normal five-stage RISC-V pipeline (ID, EX, MEM and WB).

Because all of the control and execution is handled in the Execute stage, your processor should be more or less indistinguishable from a single-cycle implementation, barring the one-cycle startup latency. However, we will be enforcing the two-stage pipeline design. Some things to consider:

Will the IF and EX stages have the same or different PC values?
Do you need to store the PC between the pipelining stages?
You might also notice a bootstrapping problem here: during the first cycle, the instruction register sitting between the pipeline stages wonâ€™t contain an instruction loaded from memory. How do we deal with this? It happens that Logisim automatically sets registers to zero on reset; the instruction register will then contain a nop. We will allow you to depend on this behavior of Logisim. Remember to go to Simulate --> Reset Simulation (Cmd + R or Ctrl + R on Windows) to reset your processor.

After pipelining your processor, you should be able to pass python3 test_runner.py part_a addi_pipelined test. Note that the single-stage test will now fail, which is expected behavior (why? look back at the reference outputs for each test, and think about the effects of pipelining on different stages).

Testing
Understanding the Tests
Each test is a copy of the run.circ file included with the starter code that has instructions loaded into its IMEM. When you run logisim-evolution from the command line, the clock ticks, the program counter is incremented, and the values in each of the outputs is printed to stdout.

Letâ€™s take as the one stage addi test as an example. It has 3 addi instructions (addi t0, x0, 5, addi t1, t0, 7, addi s0, t0, 9). Open tests/part_a/addi_pipelined/cpu-addi-pipelined.circ in Logisim Evolution, and take a closer look at the various parts of the test file. At the top, youâ€™ll see the place where your CPU is connected to the test outputs. With the starter code, youâ€™ll see all xxxxâ€™s, as you do below; when your CPU is working, this should not be the case. Your CPU takes in one input (instruction), and along with the values in each of the registers, it has one additional output: fetch_addr, or the address of the instruction to be fetched from IMEM to be executed the next clock cycle.

Be careful that you donâ€™t move any of the inputs/outputs of your CPU around, or add any additional inputs/outputs. This will change the shape of the CPU subcircuit, and as a result the connections in the test files may no longer work properly.

Below the CPU, youâ€™ll see instruction memory. The hex for the 3 addi instructions (0x00500293, 0x00728313, 0x00928413) has been loaded into instruction memory. Instruction memory takes in one input (called fetch_addr) and outputs the instruction at that address. fetch_addr is a 32-bit value, but because Logisim Evolution caps the size of ROM units at 2^16B, we have to use a splitter to get only 14 bits from fetch_addr (ignoring the bottommost two bits). Notice that fetch_addr is a byte address, not a word address.

So what happens when the clock ticks? Each tick of the clock increments an input in the test file called Time_Step. The clock will continue to tick until Time_Step is equal to the halting constant for that test file (for this particular test file, the halting constant is 5). At that point, the Logisim Evolution command line will print the values in each of your outputs to stdout. Our tests will compare this output to the expected; if your output is different, you will fail the test.

addi Tests
Weâ€™ve included 2 tests for the addi instruction with the starter code: one for a single-cycle CPU and one for a pipelined CPU. You can run the pipelined tests with the following commands (replace pipelined with single for single-cycle tests):

$ python3 test_runner.py part_a addi_pipelined # For a pipelined CPU


You can see the .s (RISC-V) and .hex (machine code) files for the test in tests/part_a/addi_pipelined/inputs.

Weâ€™ve included a Python script to interpret your output: binary_to_hex_cpu.py, which works like binary_to_hex_alu.py and binary_to_hex_regfile.py from the previous tasks. To use the script to see your CPUâ€™s output, run:

$ cd tests/part_a/addi_pipelined
$ python3 binary_to_hex_cpu.py student_output/CPU-addi-pipelined-student.out


or, to see the reference output, run:

$ cd tests/part_a/addi_pipelined
$ python3 binary_to_hex_cpu.py reference_output/CPU-addi-pipelined-ref.out


As a reminder you can find a debugging walkthrough at this video.

Part A: Submission
At this point, if youâ€™ve completed tasks 1-3, youâ€™ve finished Part A of the project!

Double-check that you have not moved your input/output pins, and that your circuits fit in the provided testing harnesses. Make sure that you did not create any additional .circ files; the autograder will only be testing the circuit files you needed to edit in the starter code (alu.circ, branch_comp.circ, control_logic.circ, cpu.circ, imm_gen.circ, and regfile.circ).

Your last bit of work before you submit is to write down how you implemented components for this part of the project readme.md. There is already a template for you to use and donâ€™t worry about going into too much detail, we just want you to reflect on what you did in this part and explain the reasoning behind the design choices you made! You must also document the breakdown of labor between you and your partner! Tell us who did what in both implementation and design.

Submit your repo to the Project 3A assignment on Gradescope.

The autograder for Part A uses the same tests as the test files provided in the starter code.

The rest of this spec describes the tasks for Part B.

Part B
Task 4: More Instructions
In Task 3, you wired up a basic pipelined CPU capable of executing addi instructions. Now, youâ€™ll implement support for more instructions!

The Instruction Set Architecture (ISA)
We will be grading your CPU implementation on only the instructions listed below. Your CPU must support these instructions, but feel free to implement any additional instructions you want as long as they donâ€™t affect your implementation of the required instructions. Implementing additional instructions will not affect your score.

Instruction	Type	Opcode	Funct3	Funct7/Immediate	Operation
add rd, rs1, rs2	R	0x33	0x0	0x00	R[rd] â† R[rs1] + R[rs2]
mul rd, rs1, rs2	0x0	0x01	R[rd] â† (R[rs1] * R[rs2])[31:0]
sub rd, rs1, rs2	0x0	0x20	R[rd] â† R[rs1] - R[rs2]
sll rd, rs1, rs2	0x1	0x00	R[rd] â† R[rs1] << R[rs2]
mulh rd, rs1, rs2	0x1	0x01	R[rd] â† (R[rs1] * R [rs2])[63:32]
mulhu rd, rs1, rs2	0x3	0x01	(unsigned) R[rd] â† (R[rs1] * R[rs2])[63:32]
slt rd, rs1, rs2	0x2	0x00	R[rd] â† (R[rs1] < R[rs2]) ? 1 : 0 (signed)
xor rd, rs1, rs2	0x4	0x00	R[rd] â† R[rs1] ^ R[rs2]
srl rd, rs1, rs2	0x5	0x00	(unsigned) R[rd] â† R[rs1] >> R[rs2]
sra rd, rs1, rs2	0x5	0x20	(signed) R[rd] â† R[rs1] >> R[rs2]
or rd, rs1, rs2	0x6	0x00	R[rd] â† R[rs1] | R[rs2]
and rd, rs1, rs2	0x7	0x00	R[rd] â† R[rs1] & R[rs2]
lb rd, offset(rs1)	I	0x03	0x0		R[rd] â† SignExt(Mem(R[rs1] + offset, byte))
lh rd, offset(rs1)	0x1		R[rd] â† SignExt(Mem(R[rs1] + offset, half))
lw rd, offset(rs1)	0x2		R[rd] â† Mem(R[rs1] + offset, word)
addi rd, rs1, imm	0x13	0x0		R[rd] â† R[rs1] + imm
slli rd, rs1, imm	0x1	0x00	R[rd] â† R[rs1] << imm
slti rd, rs1, imm	0x2		R[rd] â† (R[rs1] < imm) ? 1 : 0
xori rd, rs1, imm	0x4		R[rd] â† R[rs1] ^ imm
srli rd, rs1, imm	0x5	0x00	R[rd] â† R[rs1] >> imm
srai rd, rs1, imm	0x5	0x20	R[rd] â† R[rs1] >> imm
ori rd, rs1, imm	0x6		R[rd] â† R[rs1] | imm
andi rd, rs1, imm	0x7		R[rd] â† R[rs1] & imm
sb rs2, offset(rs1)	S	0x23	0x0		Mem(R[rs1] + offset) â† R[rs2][7:0]
sh rs2, offset(rs1)	0x1		Mem(R[rs1] + offset) â† R[rs2][15:0]
sw rs2, offset(rs1)	0x2		Mem(R[rs1] + offset) â† R[rs2]
beq rs1, rs2, offset	SB	0x63	0x0		if(R[rs1] == R[rs2])
 PC â† PC + {offset, 1b0}
bne rs1, rs2, offset	0x1		if(R[rs1] != R[rs2])
 PC â† PC + {offset, 1b0}
blt rs1, rs2, offset	0x4		if(R[rs1] < R[rs2] (signed))
 PC â† PC + {offset, 1b0}
bge rs1, rs2, offset	0x5		if(R[rs1] >= R[rs2] (signed))
 PC â† PC + {offset, 1b0}
bltu rs1, rs2, offset	0x6		if(R[rs1] < R[rs2] (unsigned))
 PC â† PC + {offset, 1b0}
bgeu rs1, rs2, offset	0x7		if(R[rs1] >= R[rs2] (unsigned))
 PC â† PC + {offset, 1b0}
auipc rd, offset	U	0x17			R[rd] â† PC + {offset, 12b0}
lui rd, offset	0x37			R[rd] â† {offset, 12b0}
jal rd, imm	UJ	0x6f			R[rd] â† PC + 4
 PC â† PC + {imm, 1b0}
jalr rd, rs1, imm	I	0x67	0x0		R[rd] â† PC + 4
 PC â† R[rs1] + {imm}
csrw rd, csr, rs1	I	0x73	0x1		CSR[csr] â† R[rs1]
csrwi rd, csr, uimm	I	0x73	0x5		CSR[csr] â† {uimm}
Info: Memory
The Memory unit (located in mem.circ) is already fully implemented for you and attached to the outputs of your CPU in test_harness.circ! You must not add mem.circ into your CPU, doing so will cause the autograder to fail and you will not receive a score.

Note that the address you give to memory is a byte address, but memory returns an entire word of memory. The memory unit ignores the bottom two bits of the address you provide to it, and treats its input as a word address rather than a byte address. For example, if you input the 32-bit address 0x0000_1007, it wil be treated as the word address 0x0000_1004, and you will get as output the 4 bytes at addresses 0x0000_1004, 0x0000_1005, 0x0000_1006, and 0x0000_1007.

Note that for the lw, lh, sh, sw instructions, the RISC-V ISA supports unaligned accesses, but implementing them is complicated. Weâ€™ll only be implementing aligned memory accesses in this project. This means that operations will only be defined when they do not exceed the boundaries of a contiguous word in memory. An example of such an operation is any lw or sw that operates on an address that is a multiple of 4. Since the address is a multiple of 4 and we load 4 bytes in a word, the total memory fetched does not exceed the boundaries of a contiguous word in memory. You must not implement unaligned accesses; you would likely need to use stalling, which would result in your output not matching our expected output (bad for your score).

Remember that the memory is also byte level write enabled. This means that the Write_En signal is 4 bits wide and acts as a write mask for the input data. For example, if Write_En is 1'b1000, only the most significant byte of the addressed word in memory will be overwritten. The ReadData port will always return the value in memory at the supplied address, regardless of Write_En.

Again, hereâ€™s a quick summary of its inputs and outputs:

Signal Name	Direction	Bit Width	Description
WriteAddr	Input	32	Address to read/write to in Memory
WriteData	Input	32	Value to be written to Memory
Write_En	Input	4	The write mask for instructions that write to Memory and zero otherwise
CLK	Input	1	Driven by the clock input to the CPU
ReadData	Output	32	Value of the data stored at the specified address
Info: Branch Comparator
The Branch Comparator unit (located in branch_comp.circ) compares two values and outputs control signals that will be used to make branching decisions. You will need to implement logic for this circuit.

To edit this subcircuit, edit the branch_comp.circ file and not the branch_comp in cpu.circ. Note that if you modify this circuit, you will need to close and open cpu.circ to load the changes in your CPU.

Again, hereâ€™s a quick summary of its inputs and outputs:

Signal Name	Direction	Bit Width	Description
rs1	Input	32	Value in the first register to be compared
rs2	Input	32	Value in the second register to be compared
BrUn	Input	1	Equal to one when an unsigned comparison is wanted, or zero when a signed comparison is wanted
BrEq	Output	1	Equal to one if the two values are equal
BrLt	Output	1	Equal to one if the value in rs1 is less than the value in rs2
Info: Immediate Generator
The Immediate Generator (â€œImm Genâ€) unit (located in imm_gen.circ) extracts the appropriate immediate from I, S, B, U, and J type instructions. Remember that in RISC-V, all immediates that leave the immediate generator are 32-bits and sign-extended! See the table below for how each immediate should be formatted:

alt-text

To edit this subcircuit, edit the imm_gen.circ file and not the imm_gen in cpu.circ. Note that if you modify this circuit, you will need to close and open cpu.circ to load the changes in your CPU.

Again, hereâ€™s a quick summary of its inputs and outputs:

Signal Name	Direction	Bit Width	Description
inst	Input	32	The instruction being executed
ImmSel	Input	3	Value determining how to reconstruct the immediate
imm	Output	32	Value of the immediate in the instruction
Info: Control Logic
The Control Logic unit (control_logic.circ) provided in the skeleton is based on the control logic unit in the 5-stage CPU used in lecture and discussion. In order to correctly identify each instruction, control signals play a very important part in this project. However, figuring out all of the control signals may seem intimidating. We suggest taking a look at the lecture slides and discussion worksheets to get started. Try walking through the datapath with different types of instructions; when you see a MUX or other component, think about what selector/enable value you will need for that instruction.

You are welcome to add more inputs or outputs to the existing starter circuit as your control logic demands. You may also use as many or as few of the supplied ports as needed. That being said, please do not change or remove any of the existing ports during this process.

There are a two major approaches to implementing the control logic so that it can extract the opcode/funct3/funct7 from an instruction and set the control signals appropriately.

The recommended method is hard-wired control, as discussed in lecture, which is usually the preferred approach for RISC architectures like MIPS and RISC-V. Hard-wired control uses â€œANDâ€, â€œORâ€, and â€œNOTâ€ gates (along with the various components weâ€™ve learned can be built from these gates, like MUXes and DEMUXes) to produce the appropriate control signals. An instruction decoder takes in an instruction and outputs all of the control signals for that instruction.

The other way to do it is to use ROM control. Every instruction implemented by a processor maps to an address in a Read-Only Memory (ROM) unit. At that address in the ROM is the control word for that instruction. An address decoder takes in an instruction and outputs the address of the control word for that instruction. This approach is common in CISC architectures like Intelâ€™s x86-64, and, in real life, offers some flexibility because it can be re-programmed by changing the contents of the ROM.

To edit this subcircuit, edit the control_logic.circ file and not the control_logic in cpu.circ. Note that if you modify this circuit, you will need to close and open cpu.circ to load the changes in your CPU.

Info: Control Status Register (CSR)
In order to run the testbenches that determine your project grades as well as the winners for the Design Contest, there are a few more instructions that need to be added. A Control Status Register (CSR) holds additional information about the results of machine instructions, and it usually is stored independently of the register file and the memory. In your processor, you will be writing outputs to one of the CSRs that will be monitored by more complex testbenches. Note that Venus does not support CSRs, so you will not be able to generate custom tests for these instructions. We will provide a robust sanity check for your CSR in the Part B autograder that will test all functionality of CSR needed.

Below are the 2 CSR instructions that you will need to implement. Note that while there are 212 possible CSR addresses, we will only use one of them (tohost = 0x51E). Note that the immediate forms use a 5-bit zero-extended immediate (uimm) encoded in the rs1 field.

csrw tohost, t2 (short for csrrw x0,csr,rs1 where csr=0x51E)
csrwi tohost, 1 (short for csrrwi x0,csr,uimm where csr=0x51E)
alt-text

The Control Status Register unit skeleton (csr.circ) is provided with the starter code. In this unit, you will need to implement the tohost CSR register along with the write logic. Please do not change the given connections as it will interfere with the testbench results!

If you want to learn more about CSR, you can refer to Chapter 9 of the RISC-V specification.

Hereâ€™s a quick summary of its inputs and outputs:

Signal Name	Direction	Bit Width	Description
CSR_address	Input	12	Input CSR register address
CSR_din	Input	32	Value to write into specified CSR register
CSR_WE	Input	1	Write enable
clk	Input	1	Clock input
tohost	Output	32	Output of the tohost register
Info: Processor
The main CPU circuit (located in cpu.circ) implements the main datapath and connects all the subcircuits (ALU, Branch Comparator, Control Logic, Immediate Generator, Memory, and RegFile) together. In Part A, you implemented a simple two-stage pipeline in your CPU. Since Part B requires support for branch and jump instructions, youâ€™ll need to handle control hazards that occur when branching.

The instruction immediately after a branch or jump is not executed if a branch is taken. This makes your task a bit more complex. By the time you have figured out that a branch or jump is in the execute stage, you have already accessed the instruction memory and pulled out (possibly) the wrong instruction. You will therefore need to â€œkillâ€ instruction that is being fetched if the instruction under execution is a jump or a taken branch.

Instruction kills for this project MUST be accomplished by MUXing a nop into the instruction stream and sending the nop into the Execute stage instead of using the fetched instruction. Notice that 0x00000013, or addi x0, x0, 0 is a nop instruction; other nop instructions will work too. You should kill if a branch is taken (do not kill otherwise). Do kill on every type of jump.

Do not solve this issue by calculating branch offsets in the IF stage. If we test your output against the reference every cycle, and the reference returns a nop, while it may be a conceptually correct solution, this will cause you to fail our tests.

Because all of the control and execution is handled in the Execute stage, your processor should be more or less indistinguishable from a single-cycle implementation, barring the one-cycle startup latency and the branch/jump delays. However, we will be enforcing the two-stage pipeline design. Some things to consider:

Will the IF and EX stages have the same or different PC values?
Do you need to store the PC between the pipelining stages?
To MUX a nop into the instruction stream, do you place it before or after the instruction register?
What address should be requested next while the EX stage executes a nop? Is this different than normal?
You might also notice a bootstrapping problem here: during the first cycle, the instruction register sitting between the pipeline stages wonâ€™t contain an instruction loaded from memory. How do we deal with this? It happens that Logisim automatically sets registers to zero on reset; the instruction register will then contain a nop. We will allow you to depend on this behavior of Logisim. Remember to go to Simulate --> Reset Simulation (Ctrl+R) to reset your processor.

CPU Testing: Pipelined Sanity Tests
Weâ€™ve provided a group of basic sanity tests for your pipelined CPU in tests/part_b/pipelined.

$ python3 test_runner.py part_b pipelined


You can see the .s (RISC-V) and .hex (machine code) files for the test in tests/part_b/pipelined/inputs.

Weâ€™ve also provided binary_to_hex_cpu.py, which works like binary_to_hex_cpu.py from Task 3.

Task 5: Custom Tests
The autograder tests fall into 3 main categories: unit tests, integration tests, and edge case tests. For Part B, we wonâ€™t be revealing all the autograder tests, but you should be able to re-create a very close approximation of them on your own in order to test your CPU.

Unit tests: a unit test exercises your datapath with a single instruction, to make sure that each individual instruction has been implemented and is working as expected. You should write a different unit test for every single instruction that you need to implement, and make sure that you test the spectrum of possibilities for that instruction thoroughly. For example, a unit test slt should contain cases where rs1 < rs2, rs1 > rs2, and where rs1 == rs2.

Integration tests: After youâ€™ve passed your unit tests, move onto tests that use multiple functions in combination. Try out various simple RISC-V programs that run a single function; your CPU should be able to handle them, if working properly. Feel free to try to use riscv-gcc to compile C programs to RISC-V, but be aware of the limited instruction set weâ€™re working with (you donâ€™t have any ecall instructions, for example). Weâ€™d recommend that you instead try to write simple functions on your own based on what youâ€™ve seen in labs, discussions, projects, and exams.

Edge case tests: edge case tests try inputs that you normally wouldnâ€™t expect, which may trigger bugs in certain situations. What edge cases should you look for? A small hint from us: our 2 main classes of edge cases come from memory operations and branch/jump operations (some of the test names are â€œmem-fullâ€ and â€œbr-jump-edgeâ€). Think about all the different ways these operations could go wrong.

Creating Custom Tests
Weâ€™ve included a script (create-test.py) that uses Venus to help you generate test circuits from RISC-V assembly! As a reminder you can find a debugging walkthrough at this video. The process for generating a custom test is as follows:

Come up the RISC-V assembly instructions for the test, and save them in a file ending in .s in the tests/part_b/custom/inputs folder. The name of this file will be the name of your test. Note that your test must end in .s, and it must be located in the tests/part_b/custom/inputs folder. Repeat if you have more tests.

e.g. tests/part_b/custom/inputs/sll-slli.s, tests/part_b/custom/inputs/slt.s
Repeat step 1 if you have more tests.

To generate test circuits for your tests, run the create-test.py script:

$ cd tests/part_b/custom
$ python3 create-test.py inputs/sll-slli.s inputs/slt.s


This should generate a couple new files:

tests/part_b/custom:
  - <TEST_NAME>.circ # The new circuit for your test
  - inputs/<TEST_NAME>.s # The test file you wrote
  - inputs/<TEST_NAME>.hex # The machine code of the test file you wrote
  - reference_outputs/<TEST_NAME>-ref.out # The reference output for your test


Now you can run your tests!

$ python3 test_runner.py part_b custom


If you want to inspect the circuit running your test, you can simulate it by opening up the CPU-<test name here>.circ file, right-clicking on the CPU, selecting â€˜view mainâ€™, and using Cmd + T (Ctrl + T on Windows) to manually tick the clock through each cycle. If you donâ€™t remember how to simulate your circuit, please refer back to the Logisim lab. We highly encourage you to poke your circuit while simulating the test to observe how your circuit reacts to various inputs (perhaps this can give you ideas for new tests to write).

If you wish to simulate your code only for a certain number of cycles, you can do that by using the -n flag:

$ python3 create_test.py -n <NUMBER_OF_CYCLES> <TEST_NAME>.s


If you would like to decode your output, use the provided binary_to_hex_cpu.py. Note that because youâ€™re implementing a 2-stage pipelined processor and the first instruction writes on the rising edge of the second clock cycle, the effects of your instructions will have a 2 instruction delay. For example, letâ€™s say you wrote a test with one instruction: addi t0, x0, 1. If you inspect the reference output, youâ€™ll see that t0 isnâ€™t changed until the third cycle.

Test Coverage
Test coverage: a metric measuring how much of a given codebase is being tested by tests. For the purposes of this project, you will be graded on how much of the required ISA your tests cover.

The autograder for Part B will examine the coverage of tests located in the tests/part_b/custom/inputs folder. When you submit Part B to the autograder, the autograder will output a message about the percentage coverage of your tests against our staff suite of tests and notify you if any of your tests raised a syntax error.

Hints:

If you make many short test files rather than one large one, it will be easier to figure out which test and which line causes your Syntax Error (and to figure out where your CPU is failing). Weâ€™d recommend that for unit testing, where you have one .s file testing each instruction.
Make sure you test every single instruction in the ISA, including the ones that are covered by the sanity tests; feel free to use the sanity tests as a model or even incorporate them as part of your test suite.
Make sure you check that all registers are working.
Make sure you donâ€™t have any â€œdummyâ€ tests; if a test doesnâ€™t lead to a change in state or register value, it is not a meaningful test.
Make sure that you accumulate outputs into the special registers we output to the testharness, other registers will not be checked against. These registers are: x0, ra, sp, t0, t1, t2, s0, s1, and a0.
Part B: Submission
At this point, if youâ€™ve completed tasks 4-5, youâ€™ve finished Part B of the project. Congratulations on your shiny new CPU!

Your last bit of work before you submit is to write down how you implemented your CPU inside the readme.md. There is already a template for you to use and donâ€™t worry about going into too much detail, we just want you to reflect on what you did in this project and explain the reasoning behind the design choices you made (especially in your control logic)! You must also document the breakdown of labor between you and your partner! Tell us who did what in both implementation and design.

Double-check that you have not moved your input/output pins, and that your circuits fit in the provided testing harnesses. Make sure that you did not create any additional .circ files; the autograder will only be testing the circuit files you needed to edit in the starter code (branch_comp.circ, control_logic.circ, cpu.circ, imm_gen.circ). Also make sure your custom .s tests are located in the right folder.

The autograder for Part B uses the sanity tests provided in the starter code, as well as hidden unit, integration, and edge case tests as specified in Task 5. Additionally, the autograder will be checking your custom tests for test coverage.

Note: If you fail on any of the provided autograder sanity tests, course staff will not help you debug your CPU unless you have recreated a similar test that also fails.

Frequently Asked Questions
Q: I have pipelined my CPU, but the autograder said it detected a single-cycle one, what is the problem?
A: If youâ€™re certain that you correctly pipelined, then it means that Logisim crashed when attempting to open your circuit. Generally this is caused by import issues, meaning you used a circuit that isnâ€™t in the correct place. Remember that you shouldnâ€™t be creating any new circ files and your ALU and RegFile files will be replaced with the staff solution, so donâ€™t use any subcircuits you created in those files in your CPU.
Q: I want to add more inputs and outputs to one of my circuits. Is this allowed?
A: This is allowed, however beware of messing up your circuit appearance. This can cause pins to move to the wrong place and make you fail all the sanity tests. You can check you circuit appearance by right-clicking on your circuit and selecting â€œEdit Circuit Appearanceâ€ to move the new pins around if necessary, though this is not recommended. WARNING: If you fail autograder tests because of added inputs/outputs we will not allow you to fix and resubmit after the deadline. If you want to add extra logic or controls to your CPU we recommend making a control subcircuit in cpu.circ.
Q: Are we allowed to use all the Logisim main library blocks? Where can I find information on them?
A: You are only allowed to use the following libraries: Wiring (except Transistor, Transmission Gate, POR, Pull Resistor, Power, Ground, POR, Do not connect), Gates, Plexers, Arithmetic (except Divider), Memory (except RAM, Random Generator) Note that the use of ROM is allowed. Help can be found in the Logisim menus
Q: I failed a sanity check in the autograder, can I get help figuring out whatâ€™s wrong?
A Course staff will be unable to help debug issues directly from the autograder. Instead, we encourage you to use the custom test generator to generate new test that replicates the operation described in the sanity test description and then bringing failed results from that test to OH.
Q: My autograder failed to run, how do I fix this?
A Please check that you have followed all the rules with regards to allowed blocks and circuit naming. Also please check that you do not have any splitters where an output of the splitter is mapped to by 0 pins (in this case you should be using a smaller splitter anyway). If you have made all these checks and fixes and are still having problems, please post on Piazza.
Grading
The grading breakdown for Project 3 is as follows:

Part A (20%)
ALU (8%)
RegFile (8%)
Pipelined addi (4%)
Part B (80%)
Sanity and Visible (Basic) Unit Tests (20%)
Test Coverage (10%)
Hidden Unit, Integration, and Edge Case Tests (50%)
For Part B we have provided a visible set of basic unit tests in the autograder. These tests are meant to help reduce your stress by providing some guidance in the early stages of testing. You should still rigorously test your designs, passing the visible tests does not guarantee that you will pass any of the hidden tests.

Design Contest
This year, thanks to support from an industry partner, Project 3 will be part of a course wide design contest! The method in which your Project 3 submission will be scored is based on the gate equivalence and longest path of your submitted circuit. In both contests, a lower score is better.

Note that while all submitted designs will show a score, only designs that pass 100% of visible and hidden tests will be eligible for the contest. This means that it is in your best interest to test throughly!

Gate equivalence
The first contest score you will receive is for gate equivalence. To calculate this, we will take your submitted circuit, and convert it to the number of NAND2 gates, NOT gates, and flip-flops required to implement your design. You will then be assigned a score based on the formula: score = 2 * (# of NOTs) + 2 * (# of NAND2s) + 8 * (# of FFs). This score is a proxy for the power consumption and area utilization of your design. The weights in our formula are derived from the number of transistors needed to replicate each type of gate or flip-flop.

A table of some common logic elements and their corresponding gate equivalents are shown below. You can assume that the gate equivalents scale roughly linearly with the total input bitwidth (i.e. a 2-input 32-bit adder has roughly 32 times the number of gates of a 2-input 1-bit adder). An exception to this rule is the multiplier, which scales roughly linearly with the square of the total input bitwidth.

Gate Name	Number of NAND2 Gates	Number of NOT Gates	Number of FFs
2-input AND	1	1	0
2-input OR	1	2	0
2-input NOR	1	3	0
32-bit ADDER	366	195	0
32-bit SUBTRACTOR	456	255	0
32-bit COMPARATOR	222	127	0
32-bit MULTIPLIER	10849	4467	0
32-bit NEGATOR	145	84	0
32-bit SHIFTER	418	36	0
2-input 32-bit MUX	128	33	0
ROM (per non-zero entry)	5.8 (average)	4.6 (average)	0
32-bit Register FF	97	1	32
Longest Path
The second contests score you will receive is for the longest path in your design. We will follow a similar process to gate equivalent but instead calculate the longest path between any two flop-flops in your design. This score is a proxy for the fastest clock frequency at which your design could run.

Tips
Simplify when possible! For example, a shifter that shifts by a fixed amount can be replicated using a splitter, which costs 0 gates!
A majority of your savings will come from optimizing your control logic.
Reduce, reuse, recycle! Use the output of a computation as many times as possible rather than performing the computation each time the value is needed.
Break apart independent computations into their own paths. If you place all your logic between two flip-flops in a single path, this is very inefficient in terms of your longest path.
Previous
Project2
Next
Project4
Overview  
Tips and Guidelines  
alt-text  
Part A: Getting Started  
Task 1: Arithmetic Logic Unit (ALU)  
ALU Testing  
Task 2: Register File (RegFile)  
RegFile Testing  
Task 3: The addi Instruction  
Info: Memory  
Info: Branch Comparator  
Info: Immediate Generator  
Info: Processor  
Info: Control Logic  
Single Stage CPU: A Guide  
Pipelining Your CPU
Testing  æµ‹è¯•
Part A: Submission  
Part B  éƒ¨åˆ† B
Task 4: More Instructions  
The Instruction Set Architecture (ISA)  
Info: Memory  
Info: Branch Comparator  
Info: Immediate Generator  
Info: Control Logic  
Info: Control Status Register (CSR)  
Info: Processor  
CPU Testing: Pipelined Sanity Tests  
Task 5: Custom Tests  
Creating Custom Tests  
Test Coverage  
Part B: Submission
Frequently Asked Questions
Grading
Design Contest
Gate equivalence
Longest Path
Tips

CSå­¦ä¹ ç¤¾åŒº
è·¯çº¿å›¾
ç¤¾åŒº
Discord
æèµ 
æèµ æˆ‘ä»¬
Copyleft Â© 2025 My Project, Inc. Built with Docusaurus.
Skip to main content
è·³è½¬åˆ°ä¸»è¦å†…å®¹
ğŸ‰ï¸ğŸ‰ï¸ğŸ‰ï¸è¯¾ç¨‹æ–‡æ¡£æ±‰åŒ–å·¥ä½œæ­£åœ¨è¿›è¡Œä¸­ ğŸ‰ï¸ğŸ‰ï¸ å­¦ä¹ äº¤æµç¾¤è¯·åˆ° ç¤¾åŒºé¡µé¢ æŸ¥çœ‹å…¥ç¾¤æ–¹å¼ ğŸ‰ï¸ğŸ‰ï¸ğŸ‰ï¸
TeachYourselfCS
TeachYourselfCS
è·¯çº¿å›¾
è¯¾ç¨‹èµ„æº
åšå®¢
ç¤¾åŒº
æèµ æˆ‘ä»¬

å‰è¨€
è·¯çº¿å›¾
è¯¾ç¨‹èµ„æº

cs50x

cs61a

cs61b

cs61c

syllabus-è¯¾ç¨‹å¤§çº²
labs
projects
  é¡¹ç›®
Project1
  é¡¹ç›® 1
Project2
  é¡¹ç›® 2
Project3
  é¡¹ç›® 3
Project4
  é¡¹ç›® 4
MIT 18.01

MIT 18.02

MIT 18.06

MIT 6.042J

cs162

cs144

CMU 15-445

py4e

è¯¾ç¨‹èµ„æºcs61cprojectsProject4
Project 4: Numc    
Overview  æ¦‚è¿°
Due Wednesday, December 4th  

This project is designed to be both a C project as well as a performance project. In this project you will be implementing a slower version of numpy. Your version of numpy, numc (how exciting!), is most likely to be slower than numpy, but much faster than the naive implementations of matrix operations. You will first complete a naive solution for some matrix functions in C, then you will experiment with the setup file in Python to install your numc module. After that, you will gain a deeper understanding of the Python-C interface by overloading some operators and defining some instance methods for numc.Matrix objects. Finally, you will speed up your naive solution, thus making numc.Matrix operations faster.  

Do not expect your final completed numc module to be as good as numpy, but you should expect a very large speedup compared to the naive solution, especially for matrix multiplication and exponentiation!  

Tips and Guidelines  
Here is a list of all the important clarifications!! For each new clarification we make, it will be reflected both in that post and the spec.  

Please start early! Because there are many more 61C students than Hive machines, you will likely share resources with your classmates. This might affect the measurement of your codeâ€™s speedup. We encourage you to use Hivemind to help balance the load amongst the hive machines.  
You will have 6 tokens every 24 hours for the Gradescope assignment.  
You can complete task 1 through 3 before the performance lectures (lec 33-35) and task 4 after. So again, please start early!  
You will get negative points up to the number of points it is worth if you fail to complete task 5, so you should do it as much as you can even if you do not complete the entire project!  
You can either allocate new matrices and throw errors in numc.c or matrix.c.  
We will not be directly testing your C code. All tests will be in Python!  
You may change the function signatures in matrix.h and matrix.c as you deem appropriate, but you may not change the function signatures in numc.h and numc.c.  
You may change the skeleton code in numc.c.  
You may NOT add/remove any additional imports.  
If you would like to run the reference solution to compare your solution to, you can import the dumbpy library on hive as we have already installed it there for you!  
For this project, we strongly suggest working on Hive machines under you cs61c account. We have set up a few environment settings that only work if you use your cs61c account.  
Getting Started  å…¥é—¨
Ssh into one of the hive machines under your cs61c class account.  

Please follow the directions in this Google Form to get a repository: https://docs.google.com/forms/d/e/1FAIpQLSc59h0HsJLPfhqbJ8hil01lrfIvK0xTPxTihB1C3KfpmkGc2Q/viewform. After completing the form, clone your GitHub Classroom repository and add the starter code repository as a remote:  

$ git clone YOUR_REPO_NAME
$ cd YOUR_REPO_NAME
$ git remote add starter https://github.com/61c-teach/fa20-proj4-starter.git


If we publish changes to the starter code, retrieve them using git pull starter master.  

To be able install the modules that you will complete in this project, you must create a virtual environment with by running  

$ python3.6 -m venv .venv


Note that you MUST use python 3.6 as our reference module dumbpy only supports this specific version of python. Finally, run the following command to activate the virtual environment:  

$ source .venv/bin/activate


This will put you in a virtual environment needed for this project. Please remember that if you exit the virtual environment and want to return to work on the project, you must re-run source .venv/bin/activate. This also means every time you re-ssh into the hive, you will have to re-run source .venv/bin/activate.  

Then, run  

pip3 install -r requirements.txt


in the virtual environment. This will install all python packages you need for running your custom python tests.  

Finally, if you have to exit out of the virtual environment, you can do so by running:  

We already have the reference library dumbpy installed for you on Hive machines. You can import it with or without the virtual environment while using python3.6, and all object and function names are the same as the numc module that you will implement (please refer to Task 3). You will only be able to access the dumbpy package on hive as we will not be directly releasing it. You can use it as a reference for both correctness and speed.  

Again, for this project, we strongly suggest working on Hive machines in your cs61c class account. You will not be able to import dumbpy if you are using other class accounts. We may be unable to help you with issues caused by working outside of the Hive.  

Task 1: Matrix functions in C  
For this task, you will need to complete all functions in matrix.c labelled with /* TODO: YOUR CODE HERE */. The comments above each function signature in matrix.c contain instructions on how to implement the functions, so read them carefully before you start coding.  

The matrix struct is defined in matrix.h. Feel free to change it, but make sure your changes are compatible with our starter code.  

typedef struct matrix {
  int rows;       // number of rows
  int cols;       // number of columns
  double **data;  // each element is a pointer to a row of data
  int is_1d;      // Whether this matrix is a 1d matrix
                  // For 1D matrix, shape is (rows * cols)
  int ref_cnt;
  struct matrix *parent;
} matrix;


rows is the number of rows of this matrix, cols is the number of columns, and data is a 2D representation of the matrix data. ref_cnt is the number of existing matrix structs (including itself) that share all or part of the data array with this particular matrix struct. is_1d is non-zero if the number of rows is 1 or the number of columns is 1. parent indicates whether this matrix struct is a slice of another matrix, and should be set to its parent matrix struct if it is and NULL otherwise.  

matrix.h also imports the library Python.h, but for this part you should not need any other functions besides PyErr_SetString.

Depending on your implementation of matrix.c and numc.c, you may or may not assume that result is already preallocated or that all inputsâ€™ dimensions are valid. However, as mentioned in the Tips and Guidelines section, your Python number methods will need to handle the case where matrix allocation fails.

Again, you may change any function signature in matrix.h and matrix.c.

Important notes:

Remember to throw a runtime error if allocate_matrix or allocate_matrix_ref fails to allocate space, or a value error if you are trying to allocate matrices with non-positive dimensions! Otherwise you would have to make sure that a runtime/value error will be thrown in numc.c whenever we run out of memory. This includes throwing an error in Matrix61c_init.
Remember to set the is_1d field when initializing matrices in allocate_matrix or allocate_matrix_ref!. Since 1D matrices are printed out differently than 2D, autograder tests may fail if is_1d is not set correctly.
The deallocate function as well as the ref_cnt field in the matrix struct have caused a lot of confusions in the past semesters. It is important to remember that this ref_cnt is NOT Pythonâ€™s internal reference count. It is simply a field that will help you implement the deallocate function. It does not have to reflect the true reference count if you deem that setting it to other values will simplify your implementation of deallocate.
For the deallocate function, since there can be multiple matrices that refer to the same data array in the memory, you must not free the data until you call deallocate on the last existing matrix that refers to that data. If you are having some difficulties implementing this, hereâ€™s a hint: you can keep the matrix struct in the memory even if you have already called deallocate on that matrix. You only need to make sure to that the struct is freed once the last matrix referring to its data is deallocated.
If this explanation does not make sense now, donâ€™t worry! It will make more sense after you implement the indexing section of task 3.
Testing for Correctness
Weâ€™ve provided some sanity in mat_test.c. These tests make several assumptions:

They assume that all result matrices are already pre-allocated with the correct dimensions and that all input dimensions are valid.
They assume that you have not modified the matrix struct in matrix.h
All tests except the tests for get and set assume that your get and set are correct
They assume that you have not modified the function signatures.
Violation of one or more of these assumptions may not cause your tests to fail, but please keep this in mind if your tests are failing and you are violating at least one of these assumptions.

To run the CUnit tests, run

in the root folder of your project. This will create an executable called test in the root folder and run it.

By default, CUnit will run these tests in Normal mode. When debugging a specific issue, it may be helpful to switch to Verbose mode, which can be done by commenting and uncommenting the relevant lines in mat_test.c:

// CU_basic_set_mode(CU_BRM_NORMAL);
CU_basic_set_mode(CU_BRM_VERBOSE);


Make sure that one line is uncommented at a time.

Please keep in mind that these tests are not comprehensive, and passing all the sanity tests does not necessarily mean your implementation is correct. This is especially true with the memory functions allocate_matrix, allocate_matrix_ref, and deallocate_matrix. Also keep in mind that the autograder will be using our own set of sanity tests. We will not directly test your C code, and will not be running your CUnit tests.

Another thing to note is that the Makefile is written for compilation on the hive machines. If you wish to run it locally, you will have to modify the Makefile by replacing the path to your CUnit/Python libraries in your CUNIT and PYTHON variables. You will also need to make sure that your local computer supports AVX extensions and OpenMP.

Finally, you are welcomed to modify mat_test.c to implement your custom test cases.

Task 2: Writing the setup file
The setup.py file is used for installing your custom-built modules. After completing it, you should be able to install numc by simply running:

This will uninstall your previously installed numc module if it existed and reinstall numc. We have written numc.c so that numc.Matrix will be initialized and ready to import upon succesful installation of the numc module. You should rerun make every time you make changes and want them to be reflected in the numc module.

You can uninstall your numc module by running

We have provided you with the compiler and linker flags in setup.py, and your task is to find out how to use them to build your module.

You will likely get a lot of warnings about functions being defined but not used, and thatâ€™s ok! You should ignore these warnings for now, and they will be gone after you finish writing Task 3.

Remember that you must be in the virtual environment that you set up in order to install the modules, otherwise you will get a â€œRead-only file systemâ€ error.

READ FIRST: take a look at the function distutils.core.setup (https://docs.python.org/3.6/distutils/apiref.html), and here is an example usage. If the documentation seems too difficult to understand, it is a good idea to take a look at the example first. You only need two function calls to complete this section, if youâ€™re doing more than that, please reread the docs included as youâ€™re likely doing something wrong

Task 3: Writing the Python-C interface
Now that you have successfully installed your numc module, you can import your numc.Matrix objects in Python programs! Here are some ready-to-use features already implemented for numc.Matrix objects. You might find them helpful when debugging Task 3.

Info: Importing numc.Matrix
Here are several ways of importing numc.Matrix

from numc import Matrix

import numc
numc.Matrix

import numc as nc
nc.Matrix


Info: numc.Matrix initialization
Here are all the different ways of creating a numc.Matrix object.

>>> import numc as nc
CS61C Fall 2020 Project 4: numc imported!
>>> nc.Matrix(3, 3) # This creates a 3 * 3 matrix with entries all zeros
[[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]
>>> nc.Matrix(3, 3, 1) # This creates a 3 * 3 matrix with entries all ones
[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
>>> nc.Matrix([[1, 2, 3], [4, 5, 6]]) # This creates a 2 * 3 matrix with first row 1, 2, 3, second row 4, 5, 6
[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]
>>> nc.Matrix(1, 2, [4, 5]) # This creates a 1 * 2 matrix with entries 4, 5
[4.0, 5.0]


More specifically:

nc.Matrix(rows: int, cols: int) will create a matrix with rows rows and cols cols. All entries in this matrix are defaulted to 0.
nc.Matrix(rows: int, cols: int, val: float/int) will create a matrix with rows rows and cols cols. All entries in this matrix will be initialized to val.
nc.Matrix(rows: int, cols: int, lst: List[int/float]) will create a matrix with rows rows and cols cols. lst must have length rows * cols, and entries of the matrix will be initialized to values of lst in a row-major order.
nc.Matrix(lst: List[List[int/float]]) will create a matrix with the same shape as the 2D lst (i.e. each list in lst is a row for this matrix).
Info: instance attributes
The matrices and vectors have an attribute shape. For a 2D matrix, it is a tuple of (rows, cols). For a 1D matrix, it is a one-element tuple of (number of elements, ) Example is given below.

>>> import numc as nc
CS61C Fall 2020 Project 4: numc imported!
>>> mat = nc.Matrix(3, 3)
>>> mat.shape
(3, 3)
>>> mat = nc.Matrix(3, 1)
>>> mat.shape
(3,)


Because 1D matricesâ€™ shapes are tricky, we are NOT testing matrix operations on your 1D matrices.

Info: Python/C API Reference
Here is the link to the full reference manual: https://docs.python.org/3.6/c-api/index.html. If you ever find anything confusing in the skeleton code or are at a lost on how to implement numc.c, this is a great resource.

Quick Overview of numc skeleton code
We define the Matrix61c struct in numc.h. It is of type PyObject (this means you can always cast Matrix61c to PyObject, but not vice versa), which according to the official documentation, â€œcontains the information Python needs to treat a pointer to an object as an objectâ€. Our Matrix61c has the matrix struct we defined in matrix.h.

Then we define a struct PyTypeObject named Matrix61cType to specify the intended behaviors of our Python object Matrix61c. This struct will then be initialized to be our numc.Matrix objects.

static PyTypeObject Matrix61cType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "numc.Matrix",
    .tp_basicsize = sizeof(Matrix61c),
    .tp_dealloc = (destructor)Matrix61c_dealloc,
    .tp_repr = (reprfunc)Matrix61c_repr,
    .tp_as_number = &Matrix61c_as_number,
    .tp_flags = Py_TPFLAGS_DEFAULT |
        Py_TPFLAGS_BASETYPE,
    .tp_doc = "numc.Matrix objects",
    .tp_methods = Matrix61c_methods,
    .tp_members = Matrix61c_members,
    .tp_as_mapping = &Matrix61c_mapping,
    .tp_init = (initproc)Matrix61c_init,
    .tp_new = Matrix61c_new
};


For example, .tp_dealloc tells Python which function to call to destroy a numc.Matrix object when its reference count becomes 0, and .tp_members tells Python what instance attributes numc.Matrix objects have. You can take a look at the official documentation if you are curious.

Useful functions:
Here is a list of some functions and Python objects from <Python.h> that you may find useful. You can also choose any other functions at this link.

PyObject_TypeCheck
PyErr_SetString
Py_BuildValue
PyTupleObject
PyLongObject
PyFloatObject
PyListObject
Now you are ready to complete numc.c, the Python-C interface! As before, you will need to fill out all functions and variables labeled /* TODO: YOUR CODE HERE */. The code for initializing the module numc and the object type numc.Matrix is already done for you. Although not required, we encourage you to take a look at the existing code to better understand the interface.

Below are the three main parts for this task.

Note: For each of the function below, we specify when you should throw each type of error. For any errors not specified, throw a runtime error.

Number Methods
For this part, we ask you to overload operators for numc.Matrix objects. Here are the expected behaviors of overloaded operators:

a + b: Element-wise sum of a and b. Returns a numc.Matrix object.
Throwing errors:
TypeError if b is not of type numc.Matrix.
ValueError if a and b do not have the same dimensions.
a - b: Element-wise subtraction of a and b. Returns a numc.Matrix object.
Throwing errors:
TypeError if b is not of type numc.Matrix.
ValueError if a and b do not have the same dimensions.
a * b: Matrix multiplication of a and b. Returns a numc.Matrix object. Remember that this is a matrix multiplication, not an element-wise multiplication.
Throwing errors:
TypeError if b is not of type numc.Matrix
ValueError if aâ€™s number of columns is not equal to bâ€™s number of rows.
-a: Element-wise negation of a. Returns a numc.Matrix object.
abs(a): Element-wise absolute value of a. Returns a numc.Matrix object.
a ** pow: Raise a to the powth power. a to the 0th power is the identity matrix (1 on the top left to bottom right diagonal and 0 everywhere else). Returns a numc.Matrix object. This operator is defined in terms of matrix multiplication, not element-wise multiplication.
Throwing errors:
TypeError if pow is not an integer.
ValueError if a is not a square matrix or if pow is negative.
Please note that for all these operations above, you must never directly modify the matrix that you pass in. You always make a new numc.Matrix object to hold your result, so make sure you set the shape attribute of the new numc.Matrix. You can use Matrix61c_new to create new numc.Matrix objects. For your convenience, hereâ€™s an example of how you create a numc.Matrix.

/* Assume new_mat is a matrix struct */
Matrix61c *rv = (Matrix61c *) Matrix61c_new(&Matrix61cType, NULL, NULL);
rv->mat = new_mat;
/* Set the shape of this numc.Matrix */
rv->shape = ...; 


For all the functions above, throw a runtime error if any error occurs (such as matrix allocation failure) and causes the operation to fail. Moreover, for any operations that involve two instances of numc.Matrix, you will have to make sure that the second instance b is indeed of type numc.Matrix as we do not support operations between numc.Matrix and other data/object types. Please read the comments in numc.c carefully.

Here is a table that tells you which function in numc.c in which you will implement each of the above operators

Operator	Function
+	Matrix61c_add
- (subtraction)	Matrix61c_sub
*	Matrix61c_multiply
- (negation)	Matrix61c_neg
abs()	Matrix61c_abs
**	Matrix61c_pow
All these functions will be called through a Python-C interface after you complete the numc module. In other words, these are the functions that will be called when you do matrix operations with numc.Matrix objects, and these interface methods will call matrix.c methods that you just implemented. You will have to check for the validity of the dimensions before actually carrying out the arithmetic, and throw an error if needed. Specifically, throw a value error if the argumentsâ€™ dimensions are invalid, and a runtime error if any memory allocation fails during execution. Again, depending on your implementation, these error checks could either be in matrix.c or numc.c

After you implement all the functions above, you will need to fill out the struct Matrix61c_as_number, which is used to define the object type numc.Matrix.

Here is the link to the official documentation of a PyNumberMethods struct: https://docs.python.org/3/c-api/typeobj.html#c.PyNumberMethods

Instance Methods
You will implement two instance methods for numc.Matrix:

set(self, i, j, val): Set selfâ€™s entry at the ith row and jth column to val.
Throwing errors:
TypeError if the number of arguments parsed from args is not 3, if i and j are not integers, or if val is not a float or int.
IndexError if i or j or both are out of range.
get(self, i, j): Returns the entry at the ith row and jth column. Throw a type error if the number of arguments parsed from args is not 2 or if the arguments are of the wrong types. Throw an index error if either i, j, or both are out of range. Return value is a Python float.
Throwing errors:
TypeError if the number of arguments parsed from args is not 2 or if either i or j is not an integer.
IndexError if i or j or both are out of range.
These functions will call get and set in matrix.c to actually get or set the value. Again, you can throw errors either in numc.c or matrix.c.

Here is a table that tells you which functions in numc.c in which you will implement each of the above instance methods

Python method	C Function
set	Matrix61c_set_value
get	Matrix61c_get_value
After you implement all the functions above, you will need to fill out the array of PyMethodDef structs Matrix61c_methods, which is used to define the object type numc.Matrix.

This link tells you what goes into a PyMethodDef struct: https://docs.python.org/3/c-api/structures.html

Indexing
After finishing this part, you should be able to index into a matrix and change either the value of one single entry or a slice. You will need to complete the following two functions:

static PyObject *Matrix61c_subscript(Matrix61c *self, PyObject *key)
This function takes in a numc matrix and the key to index into the matrix. For a 2D matrix, the key could either be an integer, a single slice, or a tuple of two slices/ints. For a 1D matrix, the key could either be an integer or a single slice. Below we provide an example for each case.

  >>> import numc as nc
  CS61C Fall 2020 Project 4: numc imported!
  >>> a = nc.Matrix(3, 3) 
  >>> a[0] # Key is a single number
  [0.0, 0.0, 0.0]
  >>> a[0:2] # key is a single slice
  [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]
  >>> a[0:2, 0:2] # key is a tuple of two slices
  [[0.0, 0.0], [0.0, 0.0]]
  >>> a[0:2, 0] # key is a tuple of (slice, int)
  [0.0, 0.0]
  >>> a[0, 0:2] # key is a tuple of (int, slice)
  [0.0, 0.0]
  >>> a[0, 0] # key is a tuple of (int, int)
  0.0
  >>> b = nc.Matrix(1, 3) # b is a 1D matrix
  >>> b[0]
  0.0
  >>> b[0:2] # Number of rows/cols does not matter now. You are slicing it as if it were a list
  [0.0, 0.0]
  >>> b[0:1, 0:1] # This is invalid!
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  TypeError: 1D matrices only support single slice!


This function returns a single number if the resulting slice is 1 by 1, otherwise it returns a new matrix that shares its data with its parent matrix. Here are more examples.

  >>> import numc as nc
  CS61C Fall 2020 Project 4: numc imported!
  >>> a = nc.Matrix(3, 3)
  >>> a[0][1]
  0.0
  >>> a[0:1, 0:1]
  0.0


When the target matrix is 1D, then it does not matter whether it has 0 row or 0 column when you are indexing it. If key is an integer, then mat[key] should return the keyth element of the matrix. If key is a single slice with start and stop, then mat[start:stop] should return another 1D matrix with stop - start elements. For example

>>> import numc as nc
CS61C Fall 2020 Project 4: numc imported!
>>> a = nc.Matrix(3, 1, [1, 2, 3])
>>> a[0]
1.0
>>> b = nc.Matrix(1, 3, [1, 2, 3])
>>> b[0]
1.0
>>> a[1:3]
[2.0, 3.0]
>>> b[1:3]
[2.0, 3.0]


Throwing errors:

If matrix is 2D, TypeError if key is not an integer, a slice, or a length-2 tuple of slices/ints. If matrix is 1D, TypeError if key is not an integer or a slice.

ValueError if key is a slice or a tuple that has one or more slices, and that at least one of these slices has step size not equal to 1, or if the length of slice is < 1. Here we provide an example for each error case to help you better understand them.

  >>> import numc as nc
  CS61C Fall 2020 Project 4: numc imported!
  >>> a = nc.Matrix(4, 4)
  >>> a[0:4:2] # Step size != 1
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  ValueError: Slice info not valid!
  >>> a[0:0] # Slice has length < 1
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  ValueError: Slice info not valid!


IndexError if key is an integer but is out of range, or if key is a tuple with at least one integer in it, and the integer is out of range.

static int Matrix61c_set_subscript(Matrix61c *self, PyObject *key, PyObject *v)
This function takes in a numc matrix, the key key to index into the matrix, and the value v to which to set the new slice. Again, the key could either be an integer, a single slice, or a tuple of two slices/ints. If the resulting slice after indexing is 1 by 1, then v should be an integer or a float. If it is an 1D matrix (1 by n or n by 1), then v should be a list of numbers, and each number can either be int or float, and the length of the list should be the same as the number of elements of this slice. If it is 2D, then v should be a 2D list where the ith element of this list is a 1D list of integers/floats to set the ith row of the slice. Below we provide an example for each case.

  >>> import numc as nc
  CS61C Fall 2020 Project 4: numc imported!
  >>> a = nc.Matrix(3, 3)
  >>> a[0:1, 0:1] = 0.0 # Resulting slice is 1 by 1
  >>> a[:, 0] = [1, 1, 1] # Resulting slice is 1D
  >>> a
  [[1.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0, 0.0, 0.0]]
  >>> a[0, :] = [2, 2, 2] # Resulting slice is 1D
  >>> a
  [[2.0, 2.0, 2.0], [1.0, 0.0, 0.0], [1.0, 0.0, 0.0]]
  >>> a[0:2, 0:2] = [[1, 2], [3, 4]] # Resulting slice is 2D
  >>> a
  [[1.0, 2.0, 2.0], [3.0, 4.0, 0.0], [1.0, 0.0, 0.0]]


Throwing errors: In addition to the errors you have to throw for invalid key types/values (see Matrix61c_subscript), you will also have to throw

TypeError if
Resulting slice is 1 by 1, but v is not a float or int.
Resulting slice is not 1 by 1, but v is not a list.
ValueError if
Resulting slice is 1D, but v has the wrong length, or if any element of v is not a float or int.
Resulting slice is 2D, but v has the wrong length, or if any element of v has the wrong length, or if any element of an element of v is not a float or int.
We suggest that you use PySlice_GetIndicesEx to extract the slicesâ€™ information. Here is the link to the documentation of this function. Moreover, you should note that slices share data with their original matrix. This means that by changing values of the slices, the values of the original matrices should also change. Here are some examples.

>>> import numc as nc
CS61C Fall 2020 Project 4: numc imported!
>>> a = nc.Matrix(2, 2)
>>> a[0:1, 0:1] = 1.0
>>> a
[[1.0, 0.0], [0.0, 0.0]]
>>> a[1] = [2, 2]
>>> a
[[1.0, 0.0], [2.0, 2.0]]
>>> b = a[1]
>>> b[1] = 3
>>> a
[[1.0, 0.0], [2.0, 3.0]]


Also note that it is possible to have nested slices, and changing the nested slicesâ€™ data should also change the original matricesâ€™ data. For example,

>>> import numc as nc
CS61C Fall 2020 Project 4: numc imported!
>>> a = nc.Matrix(4, 4)
>>> b = a[0:3, 0:3]
>>> c = b[1:3, 1:3]
>>> c[0] = [2, 2] # Changing c should change both a and b
>>> c
[[2.0, 2.0], [0.0, 0.0]]
>>> b
[[0.0, 0.0, 0.0], [0.0, 2.0, 2.0], [0.0, 0.0, 0.0]]
>>> a
[[0.0, 0.0, 0.0, 0.0], [0.0, 2.0, 2.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0]]


Now, if you didnâ€™t fully understand what the deallocate function is supposed to do when you were implementation task 1, it is now a good time to go back and take another look at it.

Again, make sure to set the shape attribute of the new slice that you make!

Testing
Refer to this section for instructions on how to test your program.

How to Debug
To debug the Python-C interface, we suggest that you write your test files in Python, and use gdb or both gdb and pdb to debug.

Using only gdb
You donâ€™t have to use pdb if you do not wish to set breakpoints in your Python test file. Open your terminal and run

Then you can set breakpoints in your C files using the normal gdb commands. gdb will warn you with

No source file named {your c file}
Make breakpoint pending on future shared library load? (y or [n])


Press â€˜yâ€™ (without the quotes) to proceed.

After that, you can run run {your python test file name}.py in gdb, and gdb will break at the breakpoints that you just set.

Using both gdb and pdb
You will have to use pdb if you wish to set breakpoints in your Python file. Hereâ€™s how it works. Start gdb by running

and set your breakpoints in C (see previous section). Then you will need to run in gdb

run -m pdb {your python file}.py


After this step, you can set breakpoints in your Python file using gdb syntax (for example, b test.py:5). With this approach, your debugger will switch between pdb and gdb depending on whether you are stepping through a Python file or a C file.

Task 4: Speeding up matrix operations
Now that you have completed the three steps above and successfully installed your naive version of numc, itâ€™s time to speed up your matrix functions in matrix.c! As of now, we are only testing PERFORMANCE on non-slice matrices. Although we ARE testing the correctness of matrix operations on matrix slices. Below we outline some steps for boosting performance.

Step 1: Unrolling and Other Optimizations
You should first try to speed up the computation by trying to apply conventional code optimizations (i.e. without using SSE or OpenMP). While we wonâ€™t tell you the exact steps, here are some hints that should help you get started:

Function calls are expensive since they involve setting up a stack frame and jumping to a different part of code. See if there are any functions that are frequently called that donâ€™t necessarily need to be.
Are there any places where you could do manual loop unrolling?
Is there any unnecessary computation being done?
Note that the above hints relate to general optimization practices. You do not necessarily need to do all of these to achieve a good speedup.

Once you have improved performance using these optimizations, you can start applying vectorization and parallelization to make the program even faster. Note that you have considerable freedom to apply any of these optimizations, and there is more than one correct solution. Try to experiment with different approaches and see which one gives you the best performance.

Step 2: SIMD Instructions
From lectures, you learned how to apply SIMD instructions to improve performance. The processors in the hive machines support the Intel AVX extensions, which allow you to do SIMD operations on 256 bit values (not just 128 bit, as we have seen in the lab). You should use these extensions to perform four operations in parallel (since all floating point numbers are doubles, which are 64 bit in size). If you are unfamiliar with SIMD instructions, lab 9 can be a good warmup.

As a reminder, you can use the Intel Intrinsics Guide as a reference to look up the relevant instructions. You will have to use the __m256d type to hold 4 doubles in a YMM register, and then use the _mm256_* intrinsics to operate on them.

Here is a list of AVX instructions that you may find helpful, although you are also allowed to use other AVX instructions not on the list.

void _mm256_storeu_pd (double * mem_addr, __m256d a)
__m256d _mm256_set1_pd (double a)
__m256d _mm256_set_pd (double e3, double e2, double e1, double e0)
__m256d _mm256_loadu_pd (double const * mem_addr)
__m256d _mm256_add_pd (__m256d a, __m256d b)
__m256d _mm256_sub_pd (__m256d a, __m256d b)
__m256d _mm256_fmadd_pd (__m256d a, __m256d b, __m256d c)
__m256d _mm256_mul_pd (__m256d a, __m256d b)
__m256d _mm256_cmp_pd (__m256d a, __m256d b, const int imm8)
__m256d _mm256_and_pd (__m256d a, __m256d b)
__m256d _mm256_max_pd (__m256d a, __m256d b)


Step 3: OpenMP
Finally you should use OpenMP to parallelize computation. Note that you will need to make sure that none of the different threads overwrites each othersâ€™ data. Just adding a #pragma omp parallel for may cause errors.

Note that the Hive machines have 4 cores with two hyperthreads each. This means that you should expect a speed-up of 4-8x (note that hyperthreads mean that two different threads execute on the same physical core at the same time; they will therefore compete for processor resources, and as a result, you will not get the same performance as if you were running on two completely separate cores).

Task 5: Tell us what you did!
Write up what you did in your README.md! While we do not have a specific format we are looking for, you should discuss what you did as a whole, the different python functions you implemented, what performance improvements you had, what were you surprised about, etc. More specifically, we want you to document your numc module and provide example usages. We expect a minimum of 6000 characters. This may seem like a lot, but documenting youâ€™ve done actually takes quite a number of words, so just sufficiently covering all the things you did in the project should get you to the word count requirement. Again, failure to complete this task may result in negative points, so make sure you do it or you will lose points!

Testing
We will not be grading your tests but we will NOT help you debug unless you have written a test which shows how your code is failing. This means just using the autograder to figure out your issues will not be acceptable for office hours.

We use unittest as the framework for testing and have provided a unittests folder that contains this framework for testing your python module. You should be familiar with unittest by now as you have had experience with it in project 2. Here is the official documentation for the standard Python unittest library. unittests/unittests.py contains all the skeleton code for both correctness and performance tests, and unittests/utils.py has all the functions that you might need in order to write tests. We have provided some sample tests for you, but it is up to you to design and code up the tests. We will not be grading your tests.

As mentioned in Tips and Guidelines and Getting Started, we have installed the naive solution which we will be comparing against on hive! The python package is called dumbpy and you can import it like any other python library (so long as you are on hive)! Please note we will not be distributing this binary which means you must work on hive if you want to test with it. You should use this and the time package to determine how much you sped up your code.

Functions in unittests/utils.py
`dp_nc_matrix(*args, kwargs)`**
This function will return a dumbpy matrix and a numc matrix that are identical. *args and **kwargs will be used as the arguments to instantiate both matrices in the exact same format as you would instantiate a numc.Matrix. We provide some examples below.

  >>> dp_mat, nc_mat = dp_nc_matrix(2, 2, 0)
  >>> dp_mat
  [[0.0, 0.0], [0.0, 0.0]]
  >>> nc_mat
  [[0.0, 0.0], [0.0, 0.0]]
  >>> dp_mat, nc_mat = dp_nc_matrix([[1, 2, 3]])
  >>> dp_mat
  [[1.0, 2.0, 3.0]]
  >>> nc_mat
  [[1.0, 2.0, 3.0]]


rand_dp_nc_matrix(rows, cols, seed=0)
This function will instantiate a random dumbpy matrix and a random numc matrix with seed. The two matrices are identical with rows rows and cols. seed is defaulted to 0.

  >>>> dp_mat, nc_mat = rand_dp_nc_matrix(2, 2, seed=5)
  >>> dp_mat
  [[0.27474559623503386, 0.046467764790387715], [0.9927552244592249, 0.08003044504673706]]
  >>> nc_mat
  [[0.27474559623503386, 0.046467764790387715], [0.9927552244592249, 0.08003044504673706]]


cmp_dp_nc_matrix(dp_mat: dp.Matrix, nc_mat: nc.Matrix)
This function will return True if dp_mat has the same size of nc_mat and all corresponding elements are equal (within a margin of error).
compute(dp_mat_lst: List[Union[dp.Matrix, int]], nc_mat_lst: List[Union[nc.Matrix, int]], op: str)
This function takes in a list of dumbpy matrices and a list of numc matrices, then applies the specified operation op on these matrices. Note that op is a string. "add", "sub", "mul", "neg", "abs", and "pow" correspond to the operations +, -(subtraction), *, -(negation), and abs, respectively. This function will return whether the computed dumbpy matrix is equal to the computed numc matrix, as well as the speedup for this specific computation.
For unary operations like "neg" and "abs", each matrix list must only contain 1 matrix. For the binary operations, they must contain more than 1 matrix.
Note that to compute "pow", dp_mat_lst and nc_mat_lst should look like something like [Matrix(2, 2), 1].
You can also do chained operations like compute([a, b, c], [d, e, f], "add") where a, b, c, d, e, f are matrices, and the function will compute a + b + c and d + e + f.
More about unittest
Running

  $ python -m unittest unittests.py -v


will run all tests in unittests.py.

If you only want to run tests of one particular class, run

  $ python -m unittest unittests.{classname} -v


For example, running

  $ python -m unittest unittests.TestAdd -v


will only run the tests under the TestAdd class.

If you want to run a specific test under a specific class, run

  $ python -m unittest unittests.{classname}.{testname} -v


For example, running

  $ python -m unittest unittests.TestAdd.test_small_add -v


will only run the test_small_add test.

Frequently Asked Questions
Task 1
Q 1.1: Will we be graded on what types of errors we threw? Or do we just have to throw some error?
A 1.1: Yes we expect you to throw the correct error types. We do not care about the error messages tho.

Q 1.2: Iâ€™m getting this when I run make test, what is happening?

  rm -f test
  gcc -g -Wall -std=c99 -fopenmp -mavx -mfma -pthread -O3 mat_test.c matrix.c -o test -fopenmp -L/home/ff/cs61c/cunit/install/lib -I/home/ff/cs61c/cunit/install/include -lcunit -I/usr/include/python3.6 -lpython3.6m
  ./test
       CUnit - A unit testing framework for C - Version 2.1-2
       http://cunit.sourceforge.net/
  Makefile:25: recipe for target 'test' failed
  make: *** [test] Illegal instruction (core dumped)



A 1.2: This means your code segfaulted before any assert statements was reached and none of the tests passed. Use gdb to locate your bug.

Q 1.3: Do we assume rows and cols start at 1 or 0?
A 1.3: They are both zero-indexed.
Q 1.4: Do our functions need to support self-referential operations? For example, mul_matrix(mat, mat, mat).
A 1.4: No.
Q 1.5: Is it reasonable to run valgrind on ./test? A 1.5: You can try, but would not recommend. Setting up valgrind for C-Python interface can be difficult.
Q 1.6: When we throw an error, is it just a fprintf call to stderr?
A 1.6: Nope, you should throw errors in a python context. i.e., when your python code calls this underlying C function, it should error. Take a look at the Python/C APIâ€™s reference manual for exception handling.
Q 1.7: Can we make a slice on slice? for example, mat1 = [[1,2,3],[4,5,6]], mat2 = mat1[0]. Can we do mat3 = mat2[0]?
A 1.7: You can make a slice on a 2D slice, but a â€œsliceâ€ on a 1D slice is just a number and is pass by value. In this case, mat3 will just be a number and changing its value will not change mat2.
Q 1.8: Does our solution need to exactly match the reference?
A 1.8: No, we allow an error margin of 1e-6.
Task 2
Q 2.1: Iâ€™m getting undefined symbols upon import (for example, undefined symbol: allocate_matrix_ref). What is happening?
A 2.1: Think about what files your module needs, especially where the undefined symbol is located.
Q 2.2: The values in my matrices change after I print their slices.
A 2.2: This is likely a memory leak. Double check your deallocate_matrix implementation. What happens when you call print(mat[0]) is that it will create a slice, then immediately deallocate it after this line.
Task 3
Q 3.1: Getting <class 'AttributeError'> -- shape.
A 3.1: Make sure the relevant method in numc.c is setting mat->shape
Q 3.2: Getting <class 'SystemError'> -- <built-in method set of numc.Matrix object at 0x7f175faffef0> returned NULL without setting an error!
A 3.2: You need to throw an error before returning NULL in any interface function.
Q 3.3: UnicodeDecodeError: â€˜utf-8â€™ codec can't decode byte 0x89 in position 5: invalid start byte upon import. Whatâ€™s wrong?
A 3.3: {NULL, NULL, 0, NULL} from starter code must be last element of Matrix61c_methods, so make sure you donâ€™t accidentally remove that!
Q 3.4: Are we allowed to call methods we wrote in matrix.c?
A 3.4: Yes please do!
Q 3.5: How do we know what gets passed into PyObject* args?
A 3.5: Read the official documentation! (You can also take a look at the starter code for examples.)
Task 4
Q 4.1: #pragma omp parallel for above a simple for loop slows down my add_matrix drastically?
A 4.1: You need big matrices to actually see the effect of speedup (something around 1000 * 1000).

Q 4.2: Iâ€™m getting warning: ignoring #pragma omp parallel [-Wunknown-pragmas] but I have not changed the Makefile?
A 4.2: It might be your task 2. Take a look at the compiler and linker flags we provided you.

Q 5.1: Iâ€™m passing my local correctness tests but failing autograder. What might be the case?
A 5.1: Here are some common sources of bugs. 1. Make sure you test your matrix operations on non-integer floating point values (such as 1.2, 1.3). In the past semester, some studentsâ€™ code was only able to generate correct results when every floating point value in their matrices were integer-valued floating points (such as 1.0, 2.0). 2. Make sure you are setting the shape attribute of every returned matrix! 3. Please do NOT modify anything related to generating random matrices! Do NOT try to speed them up! We use those to generate matrices to test on the autograder. We donâ€™t include the time for generating matrices when testing for performance.

Q 5.2: Performance tests are failing but correctness tests all pass.
A 5.2: Our performance tests test on much larger matrices than the correctness tests, so make sure you handle those cases correctly!

Q 5.3: Failing tests that are related to throwing errors.
A 5.3: Make sure you are throwing the correct type of error, not just any error.

Grading
The grading breakdown for Project 4 is as follows:

Correctness: 55%
Speedup: 40%
Multiplication: 20%
Power: 25%
Simple: 12.5%
Comprehensive: 42.5%
README.md: 5%
Here are the graphs for the speedup tests. The x-axis is your speedup times and the y-axis indicates what percentage of that testâ€™s total score you will receive.  Minimum speedup for 100% on each test:

Multiplication: 95x
Power: 1700x
Simple: 4.9x
Comprehensive: 98x
Since we are running your submissions on hive, albeit reserved, speedup times may fluctuate a bit. You should try to go above the speedup value as we will rerun the ag after the deadline and your speedup may go up or down. We will not rerun submissions if they went down unless we made another change to the autograder.

We will only be using your matrix.h, matrix.c, numc.c, setup.py, and README.md for grading. Gradescope only shows you all the core correctness tests that are needed to run performance tests. Other tests will stay hidden until the late due date.

Performance Contest
We are doing a performance contest for Project 4 this year! The method in which your Project 4 submission will be scored is based on the performance on your numc module. Note that while all submitted designs will show a score, only submissions that pass 100% of visible and hidden tests will be eligible for the contest. This means that it is in your best interest to test throughly!

We are still determining which benchmark(s) will be used in evaluating your solution and will update the spec once we have finalized that.

Previous
Project3
Next
MIT 18.01 | Fall 2006
Overview  æ¦‚è¿°
Tips and Guidelines  æŠ€å·§å’ŒæŒ‡å—
Getting Started  å…¥é—¨æŒ‡å—
Task 1: Matrix functions in C  
Testing for Correctness  æµ‹è¯•æ­£ç¡®æ€§
Task 2: Writing the setup file  
Task 3: Writing the Python-C interface  
Info: Importing numc.Matrix  
Info: numc.Matrix initialization  
Info: instance attributes  
Info: Python/C API Reference  
Quick Overview of numc skeleton code  
Useful functions:  
Number Methods  
Instance Methods  
Indexing  
Testing  æµ‹è¯•
How to Debug  
Task 4: Speeding up matrix operations  
Step 1: Unrolling and Other Optimizations  
Step 2: SIMD Instructions  
Step 3: OpenMP  
Task 5: Tell us what you did!  
Testing  æµ‹è¯•
Functions in unittests/utils.py  
More about unittest  
Frequently Asked Questions
å¸¸è§é—®é¢˜
Task 1  
Task 2  
Task 3  
Task 4  
Grading
Performance Contest

CSå­¦ä¹ ç¤¾åŒº
è·¯çº¿å›¾
ç¤¾åŒº
Discord
æèµ 
æèµ æˆ‘ä»¬
Copyleft Â© 2025 My Project, Inc. Built with Docusaurus.